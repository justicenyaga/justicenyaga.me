[{"content":"","date":"25-02-2024","permalink":"/series/data-structures-and-algorithms/","section":"Series","summary":"","title":"Data Structures and Algorithms"},{"content":"","date":"25-02-2024","permalink":"/tags/data-structures-and-algorithms/","section":"Tags","summary":"","title":"data-structures-and-algorithms"},{"content":"","date":"25-02-2024","permalink":"/tags/java/","section":"Tags","summary":"","title":"java"},{"content":"","date":"25-02-2024","permalink":"/","section":"Justice Nyaga","summary":"","title":"Justice Nyaga"},{"content":"","date":"25-02-2024","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"25-02-2024","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"25-02-2024","permalink":"/tags/stacks/","section":"Tags","summary":"","title":"stacks"},{"content":"Introduction # Stacks are powerful data structures with a simple yet versatile nature. They operate on the Last In, First Out (LIFO) principle, making them ideal for tasks like:\nUndo/redo functionality in application Implementing compilers (syntax checking) Evaluating arithmetic expressions (e.g., 1 + 2 * 3) Building navigation systems (e.g., forward and back buttons) Undestanding stacks # Think of stacks as a pile of books. You can stack them on top of each other, but you can only interact with or remove the top book on the pile. This LIFO behaviour translates perfectly to stacks in programming. Elements are added (pushed) and removed (popped) from the top, making them efficient for scenarios where you revisit actions in reverse order.\nStack Operations # Stacks support four primary operations:\npush(item): Add an item to the top of the stack. pop(): Remove the item from the top of the stack. peek(): Return the item on the top without removing it. isEmpty(): Check if the stack is empty. Runtime Complexity # Stacks are implemented using either arrays or linked lists. This makes stacks efficient because inserting, removing, or retrieving items at the end of arrays or linked lists is quick. This means that all primary stack operations have a constant runtime complexity of O(1).\nWorking with Stacks in Java # In Java, stacks are implemented through the Stack class in the java.util package. The following code snippet demonstrates the practicle usage of stacks in Java.\nimport java.util.Stack; public class Main { public static void main(String[] args) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;Integer\u0026gt;(); stack.push(10); stack.push(20); stack.push(30); System.out.println(stack); // [10, 20, 30] var top = stack.pop(); System.out.println(top); // 30 System.out.println(stack); // [10, 20] System.out.println(stack.isEmpty()); // false top = stack.peek(); System.out.println(top); // 20 System.out.println(stack); // [10, 20] } } Exercise 1: Reversing a String # A common interview question involves reversing a string. This can be efficiently solved using a stack as shown on the snippet below:\nimport java.util.Stack; public class StringReverser { public String reverse(String input) { if (input == null) throw new IllegalArgumentException(); Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // Push each character from the input string onto the stack for (char ch : input.toCharArray()) stack.push(ch); // Pope each character from the stack and append to the reversed string StringBuffer reversed = new StringBuffer(); while (!stack.empty()) reversed.append(stack.pop()); // Convert the StringBuffer into a string and return the result return reversed.toString(); } } public class Main { public static void main(String[] args) { String str = \u0026#34;abcd\u0026#34;; StringReverser reverser = new StringReverser(); var result = reverser.reverse(str); System.out.println(result); // Output: \u0026#34;dcba\u0026#34; } } Exercise 2: Balanced Expressions # Another common interview question involves checking the balance of brackets within a string, that is, ensuring that each opening bracket has a corresponding closing bracket and that no closing bracket lacks an opening bracket pair. For instance, the expression \u0026ldquo;(1 + 2)\u0026rdquo; is balanced, as each opening bracket is appropriately paired with a closing bracket. Similarly, the expression \u0026ldquo;(1 + [3 * (2 + 1)] + 10)\u0026rdquo; is balanced since each bracket in the expression has a corresponding closing bracket. On the contrary, expressions like \u0026ldquo;)1 + 2(\u0026rdquo; and \u0026ldquo;((1 + 2)\u0026rdquo; are unbalanced, as they feature closing brackets without corresponding opening brackets and opening brackets without corresponding closing brackets.\nSolution in Code\nimport java.util.Arrays; import java.util.List; import java.util.Stack; public class Expression { // Constants for left and right brackets private final List\u0026lt;Character\u0026gt; leftBrackets = Arrays.asList(\u0026#39;(\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;{\u0026#39;); private final List\u0026lt;Character\u0026gt; rightBrackets = Arrays.asList(\u0026#39;)\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;]\u0026#39;, \u0026#39;}\u0026#39;); // Checks if the provided string has balanced brackets. public boolean isBalanced(String input) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (char ch : input.toCharArray()) { if (isLeftBracket(ch)) stack.push(ch); else if (isRightBracket(ch) \u0026amp;\u0026amp; (stack.empty() || !bracketsMatch(stack.pop(), ch))) return false; } return stack.empty(); } // Checks if the character is a left bracket. private boolean isLeftBracket(char ch) { return leftBrackets.contains(ch); } // Checks if the character is a right bracket. private boolean isRightBracket(char ch) { return rightBrackets.contains(ch); } // Checks if the provided brackets correspond to each other. return leftBrackets.indexOf(left) == rightBrackets.indexOf(right); } } Testing the implementation\npublic class Main { public static void main(String[] args) { Expression exp = new Expression(); String str1 = \u0026#34;(1 + 2)\u0026#34;; String str2 = \u0026#34;{1 + 2\u0026#34;; String str3 = \u0026#34;(([1] + \u0026lt;2\u0026gt;)) [a]\u0026#34;; String str4 = \u0026#34;((\u0026lt;1] + [2\u0026gt;)) [a]\u0026#34;; var result1 = exp.isBalanced(str1); var result2 = exp.isBalanced(str2); var result3 = exp.isBalanced(str3); var result4 = exp.isBalanced(str4); System.out.println(result1); // Output: true System.out.println(result2); // Output: false System.out.println(result3); // Output: true System.out.println(result4); // Output: false } } Exercise 3: Building a Stack using an Array # Now that we\u0026rsquo;ve grasped the fundamentals of a stack, let\u0026rsquo;s take a hands-on approach and build a stack from scratch. This exercise will deepen our understanding of how stacks work. We\u0026rsquo;ll focus on implementing essential operations like push, pop, peek, and isEmpty.\nSolution in Code\nimport java.util.Arrays; public class Stack { private int[] items = new int[5]; // Array to store the stack items private int count = 0; // Count to track items in the stack // Add the given item to the end of the stack public void push(int item) { if (count == items.length) throw new StackOverflowError(); // Throw error if stack is full items[count++] = item; // Add item to array and increment count } // Remove the last item in the stack public int pop() { if (count == 0) throw new IllegalStateException(); // Throw exception if stack is empty return items[--count]; // Return last item and decrement count } // Return the last item in the stack public int peek() { if (count == 0) throw new IllegalStateException(); // Throw exception if stack is empty return items[count - 1]; // Return last item } // Check if the stack is empty public boolean isEmpty() { return count == 0; } // Override toString to print items in the stack @Override public String toString() { var content = Arrays.copyOfRange(items, 0, count); // Copy only items in the stack return Arrays.toString(content); // Return string representation of items in the stack } } Testing the implementation\npublic class Main { public static void main(String[] args) { Stack stack = new Stack(); System.out.println(stack.isEmpty()); // Output: true // stack.pop(); // Throws an IllegalStateException exception since the stack is // empty // Add items to the stack stack.push(10); stack.push(20); stack.push(30); stack.push(40); stack.push(50); // stack.push(60); // Throws a StackOverflowError since the stack is full System.out.println(stack); // Output: [10, 20, 30, 40, 50] System.out.println(stack.isEmpty()); // Output: false System.out.println(stack.pop()); // Output: 50 System.out.println(stack); // Output: [10, 20, 30, 40] System.out.println(stack.peek()); // Output: 40 System.out.println(stack); // Output: [10, 20, 30, 40] } } Summary # In this article, we have explored the stack data structure. We have learnt that:\nStacks operate on the Last In First Out (LIFO) principle. Stacks can be implemented using either arrays or linked lists. All primary operations in stacks have a runtime complexity of O(1). References # Mosh Hamedani. Ultimate Data Structures \u0026amp; Algorithms: Part 1 ","date":"25-02-2024","permalink":"/posts/202402-stacks-data-structure/","section":"Posts","summary":"Introduction # Stacks are powerful data structures with a simple yet versatile nature. They operate on the Last In, First Out (LIFO) principle, making them ideal for tasks like:\nUndo/redo functionality in application Implementing compilers (syntax checking) Evaluating arithmetic expressions (e.","title":"Stacks Data Structure"},{"content":"","date":"25-02-2024","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"Introduction # Linked lists provide a dynamic way of storing and managing data, allowing for automatic growth and shrinkage. Unlike arrays, linked lists consist of nodes, each holding a value and a reference to the next node in the sequence.\nThe initial node is termed the Head, and the final one is the Tail.\nTime Complexity Analysis # Let\u0026rsquo;s examine the time complexity of various operations:\n1. Search Operation : # To find out if a list contains a given number, we have to traverse the list from Head to Tail which results in a time complexity of O(n).\n2. Index-based Lookup: # Due to the non-sequential nature of linked list nodes in memory, searching by index also takes O(n) time.\n3. Insertions: # Inserting at the End # To add a new item at the end of the linked list, we create a new node and have the Tail reference it.\nNow, we update the Tail to point to the new node.\nThis operation is efficient with a time complexity of O(1).\nInserting at the Beginning # Adding a new item at the beginning is equally fast. With a reference to the Head, we create a new node and link it to the first node.\nThen, we update the Head to point to the new node.\nThis operation is swift, just like inserting at the end, with a time complexity of O(1).\nInserting in the Middle # If we wish to insert an item after a specific node, like the tenth node, we first traverse to find that node O(n), then update the links O(1) which results to O(n).\n4. Deletions: # Deleting from the Beginning # Removing the first item is a quick O(1) operation. We simply update the Head to point to the second node.\nThen, we remove the link from the previous Head so that it doesn\u0026rsquo;t reference the second node anymore.\nDeleting from the End # Deleting the last item is a bit more involved. We traverse the list to find the second-to-last node, keep a reference to it, and unlink it from the last node.\nFinally, we have the Tail point to the second-to-last node.\nThis operation has a time complexity of O(n).\nDeleting from the Middle # Deleting from the middle requires traversing to find the node and its previous node. We link the previous node to the next node, then remove the links on the node we\u0026rsquo;re deleting.\nFinally, we remove the links on the node we\u0026rsquo;re deleting, ensuring it can be cleared from memory.\nThis operation also has a time complexity of O(n).\nWorking with Linked Lists in Java # Now, let\u0026rsquo;s explore working with linked lists in Java using the LinkedList class from java.util. This class allows for generic data storage.\nimport java.util.LinkedList; public class Main { public static void main(String[] args) { // Initialize the linked list LinkedList\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // Add items to the end list.addLast(10); list.addLast(20); list.addLast(30); System.out.println(list); // Output: [10, 20, 30] // Add at the beginning list.addFirst(5); System.out.println(list); // Output: [5, 10, 20, 30] // Remove the last item list.removeLast(); // Remove the first item list.removeFirst(); // Remove item with index list.remove(1); // Check if list contains a given item System.out.println(list.contains(10)); // Output: true // Get the index of the first occurence of an item System.out.println(list.indexOf(10)); // Output: 0 // Get the index of the last occurence of an item list.addLast(10); System.out.println(list.lastIndexOf(10)); // Output: 1 // Get the size of the list System.out.println(list.Size()); // Output: 2 // Convert the Linked list to an Array list.toArray(); } } Don’t let the output fool you, it looks like any array, but we are actually dealing with a linked list and not an array.\nExercise 1: Creating a Linked List # To gain a deeper understanding of linked lists, let\u0026rsquo;s implement a linked list from scratch. We\u0026rsquo;ll need two classes:\nNode class:\nFields: value (int), next (Node) LinkedList class:\nFields: first (Node), last (Node) Methods: addFirst, addLast, deleteFirst, deleteLast, contains, indexOf Implementing the LinkedList # import java.util.NoSuchElementException; public class LinkedList { // Node class encapsulates details of the nodes private class Node { private int value; private Node next; // Constructor ensures a node must have a value public Node(int value) { this.value = value; } } private Node first; // Head of the linked list private Node last; // Tail of the linked list private int size; // Track the number of nodes in the list // Add a new node at the end of the linked list public void addLast(int item) { var node = new Node(item); // Check if the list is empty if (isEmpty()) { first = last = node; } else { last.next = node; last = node; } size++; } // Add a new node at the beginning of the linked list public void addFirst(int item) { var node = new Node(item); // Check if the list is empty if (isEmpty()) { first = last = node; } else { node.next = first; first = node; } size++; } // Check if the list is empty private boolean isEmpty() { return first == null; } // Return the index of the first occurrence of a node with a value equal to the given item public int indexOf(int item) { int index = 0; var current = first; while (current != null) { if (current.value == item) return index; current = current.next; index++; } return -1; } // Return true if a node exists with a value equal to the given item public boolean contains(int item) { return indexOf(item) != -1; } // Remove the first node of the linked list public void removeFirst() { if (isEmpty()) throw new NoSuchElementException(); if (first == last) first = last = null; else { var second = first.next; first.next = null; first = second; } size--; } // Remove the last node of the linked list public void removeLast() { if (isEmpty()) throw new NoSuchElementException(); if (first == last) first = last = null; else { var previous = getPrevious(last); last = previous; last.next = null; } size--; } // Return the node before the given node (parent node) private Node getPrevious(Node node) { var current = first; while (current != null) { if (current.next == node) return current; current = current.next; } return null; } // Return the size of the linked list (number of nodes in the list) public int size() { return size; } // Return an array of the values stored in the nodes public int[] toArray() { int[] array = new int[size]; var current = first; var index = 0; while (current != null) { array[index++] = current.value; current = current.next; } return array; } } Testing the implementation # import java.util.Arrays; public class Main { public static void main(String[] args) { var list = new LinkedList(); // Adding items to the end of the list list.addLast(10); list.addLast(20); list.addLast(30); // Adding an item to the beginning of the list list.addFirst(5); // Checking the index of an item, for example, 30: System.out.println(list.indexOf(30)); // Output: 3 // Checking the index of an item that is not in the list: System.out.println(list.indexOf(100)); // Output: -1 // Checking if the list contains a node with a given value System.out.println(list.contains(5)); // Output: true // Removing the first item from the list list.removeFirst(); // Removing the last item from the list list.removeLast(); // Getting the size of the list System.out.println(list.size()); // Output: 2 // Converting the list to an array var array = list.toArray(); System.out.println(Arrays.toString(array)); // Output: [10, 20] } } Arrays vs Linked Lists # A common interview question involves comparing arrays and linked lists. Differences in terms of required memory and time complexity of various operations are summarized below.\nSpace\nStatic arrays have a fixed size. Dynamic arrays grow by 50-100% when full, potentially wasting memory. Linked lists take only the necessary memory but require extra space for node references. Runtime Complexity\nOperation Arrays Linked Lists Lookup by Index O(1) O(n) Lookup by Value O(n) O(n) Insert at End O(1) O(1) Insert at Start O(n) O(1) Insert in Middle O(n) O(n) Delete from Start O(n) O(1) Delete from End O(1) O(n) Delete from Middle O(n) O(n) Types of Linked Lists # There are two main types of linked lists: singly and doubly linked lists.\nSingly Linked List\nIn singly linked list, each node references the next node in the sequence.\nDoubly Linked List\nIn doubly linked list, each node has references to both the next and previous nodes.\nCircular Linked List\nBoth singly and doubly linked lists can be circular, where the last node references the first node.\nExercise2: Reversing a Linked List # One common interview question involves reversing a linked list in place. Let me illustrate this concept. Consider a linked list shown below:\n[10 -\u0026gt; 20 -\u0026gt; 30] To reverse it, we need to change the direction of these links:\n[10 \u0026lt;- 20 \u0026lt;- 30] =\u0026gt; [30 -\u0026gt; 20 -\u0026gt; 10] Here, 30 becomes the new Head, and 10 becomes the new Tail.\nSolution Algorithm Design # We will start from the beginning, utilizing two variables/references: previous and current. In the first iteration, previous points to the first node, and current references the second node.\n[10 -\u0026gt; 20 -\u0026gt; 30] p c To alter the link between p and c, we can use c.next = p. After executing that, the link between 20 and 30 is removed, and now 20 references 10.\n[10 \u0026lt;- 20 30] p c In the second iteration, we work with the second and third nodes. However, after executing c.next = p, we lose track of 30 because we no longer have a reference to it from 20. To address this, we store a reference to 30 as a backup before executing the statement c.next = p.\n[10 -\u0026gt; 20 -\u0026gt; 30] p c n = c.next c.next = p [10 \u0026lt;- 20 30] p c n After these two steps, we are ready to move one step forward. Now our pointers/references look like this:\n[10 \u0026lt;- 20 30] p c n Once again, we make current reference previous using c.next = p, and since there is no next node after current (as current is currently referencing the last node), next will be null.\n[10 \u0026lt;- 20 \u0026lt;- 30] p c n Now, 30 references 20. We are ready to move one step forward. previous references 30, while current and next reference null. This is when we stop, i.e., when current references null.\n[10 \u0026lt;- 20 \u0026lt;- 30] p c n This process effectively reverses the linked list in place.\nImplementing Solution in Code # After formulating an efficient algorithm to reverse a linked list, let\u0026rsquo;s now bring our solution to life in code. We\u0026rsquo;ll be integrating a reverse() method into our LinkedList class, as illustrated in the snippet below.\npublic class LinkedList { // Previous code // Reverses the order of the linked list in-place. public void reverse() { if (isEmpty()) return; // Initialize pointers for traversing and reversing var previous = first; var current = first; // Traverse the list and reverse the order while(current != null) { var next = current.next; // Backup the reference to the next node current.next = previous; // Reverse the link, making current point to the previous node previous = current; // Move the previous pointer forward to the current node current = next; // Move the current pointer forward to the next node (using the backup) } last = first; // Update the Tail to point to the previous Head last.next = null; // Ensure Tail doesn\u0026#39;t have a next node (end of the reversed list) first = previous; // Update Head to point to the previous pointer (former Tail) } } Testing in Main\nimport java.util.Arrays; public class Main { public static void main(String[] args) { var list = new LinkedList(); list.addLast(10); list.addLast(20); list.addLast(30); list.reverse(); var array = list.toArray(); System.out.println(Arrays.toString(array)); // Output: [30, 20, 10] } } Exercise3: Find Kth Node from End # Let\u0026rsquo;s delve into another common interview question: \u0026ldquo;Find the Kth node from the end of a linked list in one pass.\u0026rdquo; Consider the following linked list as an example:\n[10 -\u0026gt; 20 -\u0026gt; 30 -\u0026gt; 40 -\u0026gt; 50]\nFor various values of K:\nK = 1 (Output: 50) K = 2 (Output: 40) K = 3 (Output: 30) When tackling such questions, start by simplifying them. Instead of aiming to find the Kth node from the end, try to solve a specific instance, such as the 3rd node from the end. Once you solve this, you can then generalize your algorithm.\nFormulating Solution # The trick in this question is to find the target node in one pass, and a handy approach involves using two pointers, each pointing to different nodes in the linked list. For instance, we can initialize two pointers to point at nodes 10 and 30:\n[10 -\u0026gt; 20 -\u0026gt; 30 -\u0026gt; 40 -\u0026gt; 50] * * Now, move these two pointers until the last pointer points to the last node:\n[10 -\u0026gt; 20 -\u0026gt; 30 -\u0026gt; 40 -\u0026gt; 50] * * Stop at this point, and the first pointer will be pointing at the target node. To generalize, for finding the Kth node from the end, set the distance between the two pointers to be K - 1 nodes.\nCode Implementation # public class LinkedList { // Previous code // Finds and returns the value of the Kth node from the end of the linked list public int getKthFromEnd(int k) { // Check if the list is empty if (isEmpty()) { throw new IllegalStateException(\u0026#34;Cannot find Kth node in an empty list.\u0026#34;); } // Initialize two pointers to track the Kth node var firstPointer = first; var secondPointer = first; // Move the second pointer to the right distance from the first node for (int i = 0; i \u0026lt; k - 1; i++) { secondPointer = secondPointer.next; // Check if the value of k is larger than the actual size of the linked list if (secondPointer == null) { throw new IllegalArgumentException(\u0026#34;The value of k is larger than the actual size of the linked list.\u0026#34;); } } // Move both pointers together until the second pointer reaches the last node while (secondPointer != last) { firstPointer = firstPointer.next; secondPointer = secondPointer.next; } // Return the value of the target node return firstPointer.value; } } Testing the Implementation\npublic class Main { public static void main(String[] args) { var list = new LinkedList(); list.addLast(10); list.addLast(20); list.addLast(30); list.addLast(40); list.addLast(50); System.out.println(list.getKthFromEnd(3)); // Output: 30 } } Summary # Let\u0026rsquo;s quickly recap the key points we have learned about linked lists.\nLinked lists are the second most used data structures after arrays. Unlike arrays, they grow and shrink automatically without wasting memory. They take a bit more memory because each node should have a reference to the next and/or previous node. Runtime Complexities\nLookup By Index: O(n) By Value: O(n) Insert Beginning/End: O(1) Middle: O(n) Delete Beginning: O(1) Middle: O(n) End: O(n) in singly-linked list / O(1) in doubly-linked lists Conclusion # Linked lists are powerful data structures with distinct advantages, providing flexibility in memory management compared to arrays. Their dynamic resizing capabilities make them ideal for scenarios where the size of the data structure may vary over time.\nHowever, it\u0026rsquo;s crucial to consider the trade-offs. Linked lists incur a slightly higher memory cost due to node references, and certain operations, such as random access, can have higher time complexities compared to arrays.\nReferences # Mosh Hamedani. Ultimate Data Structures \u0026amp; Algorithms: Part 1 ","date":"20-02-2024","permalink":"/posts/202402-linked-lists-data-structure/","section":"Posts","summary":"Introduction # Linked lists provide a dynamic way of storing and managing data, allowing for automatic growth and shrinkage. Unlike arrays, linked lists consist of nodes, each holding a value and a reference to the next node in the sequence.","title":"Linked Lists Data Structure"},{"content":"","date":"20-02-2024","permalink":"/tags/linked-lists/","section":"Tags","summary":"","title":"linked-lists"},{"content":"","date":"17-02-2024","permalink":"/series/my-neovim-configuration/","section":"Series","summary":"","title":"My Neovim Configuration"},{"content":"In this article, I\u0026rsquo;ll be sharing the keymaps I\u0026rsquo;ve configured within my Neovim setup to enhance simplicity and improve efficiency.\nBasic Keymaps # Keymap Mode Description \u0026lt;Space\u0026gt; N/A Leader key jk Insert Exit insert mode \u0026lt;leader\u0026gt;nh Normal Clear search highlights \u0026lt;C-a\u0026gt; Normal Select all + Normal Increment number under cursor - Normal Decrement number under cursor \u0026lt;leader\u0026gt;rw Normal Toggle Find \u0026amp; Replace \u0026lt;leader\u0026gt;rc Normal Toggle Find \u0026amp; Replace for word under cursor \u0026lt;C-z\u0026gt; Normal \u0026amp; Terminal Toggle FTerm terminal Window Management Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;sv Normal Split window vertically \u0026lt;leader\u0026gt;sh Normal Split window horizontally \u0026lt;leader\u0026gt;se Normal Make split windows equal width \u0026amp; height \u0026lt;leader\u0026gt;sm Normal Maximize/Minimize a split window \u0026lt;leader\u0026gt;sx Normal Close current slit window Tab Management Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;to Normal Open new tab \u0026lt;leader\u0026gt;tx Normal Close current tab \u0026lt;leader\u0026gt;tn Normal Go to next tab \u0026lt;leader\u0026gt;tp Normal Go to previous tab \u0026lt;leader\u0026gt;tf Normal Move current buffer to new tab Window Navigation Keymaps # Keymap Mode Description \u0026lt;C-h\u0026gt; Normal Move cursor to the window on the left \u0026lt;C-j\u0026gt; Normal Move cursor to the window below \u0026lt;C-k\u0026gt; Normal Move cursor to the window above \u0026lt;C-l\u0026gt; Normal Move cursor to the window on the right This works with my Tmux confnguration, so be sure to check it out as well. Link provided on the Recommendations section. File Explorer Keymaps # Explore the various keymaps of nvim-tree by opening the QUICKSTART HELP with g? while the cursor is on the explorer split. Close the help menu using q key. Keymap Mode Description \u0026lt;leader\u0026gt;ee Normal Toggle file explorer \u0026lt;leader\u0026gt;ef Normal Toggle file explorer on the current file \u0026lt;leader\u0026gt;ec Normal Collapse file explorer \u0026lt;leader\u0026gt;er Normal Refresh file explorer Navigation within Code # Keymap Mode Description ]f Normal Jump to next function call start ]m Normal Jump to next method/function definition start ]c Normal Jump to next class start ]i Normal Jump to next conditional start ]l Normal Jump to next loop start [f Normal Jump to previous function call start [m Normal Jump to previous method/function definition start [c Normal Jump to previous class start [i Normal Jump to previous conditional start [l Normal Jump to previous loop start Keymap Mode Description ]F Normal Jump to next function call end ]M Normal Jump to next method/function definition end ]C Normal Jump to next class end ]I Normal Jump to next conditional end ]L Normal Jump to next loop end [F Normal Jump to previous function call end [M Normal Jump to previous method/function definition end [C Normal Jump to previous class end [I Normal Jump to previous conditional end [L Normal Jump to previous loop end Keymap Mode Description ]s Normal Jump to next scope ]z Normal Jump to next fold Swap Text Objects in Code # Keymap Mode Description \u0026lt;leader\u0026gt;na Normal Swap parameter/argument with the next \u0026lt;leader\u0026gt;nm Normal Swap function with the next \u0026lt;leader\u0026gt;pa Normal Swap parameter/argument with the previous \u0026lt;leader\u0026gt;pm Normal Swap function with the previous Manipulate Text Objects in Code # In Normal mode, you can use the following key bindings prefixed with operations like d, c, or y to interact with text objects. Here are some examples:\ndaa: Delete the outer part of an argument. caa: Change the outer part of an argument. yaa: Yank the outer part of an argument. And so on.\nKeymap Mode Description a= Normal \u0026amp; Visual Select outer part of an assignment i= Normal \u0026amp; Visual Select inner part of an assignment l= Normal \u0026amp; Visual Select left hand side of an assignment r= Normal \u0026amp; Visual Select right hand side of an assignment aa Normal \u0026amp; Visual Select outer part of a parameter/argument ia Normal \u0026amp; Visual Select inner part of a parameter/argument ai Normal \u0026amp; Visual Select outer part of a condition ii Normal \u0026amp; Visual Select inner part of a condition al Normal \u0026amp; Visual Select outer part of a loop il Normal \u0026amp; Visual Select inner part of a loop af Normal \u0026amp; Visual Select outer part of a function call if Normal \u0026amp; Visual Select inner part of a function call am Normal \u0026amp; Visual Select outer part of a method/function definition im Normal \u0026amp; Visual Select inner part of a method/function definition ac Normal \u0026amp; Visual Select outer part of a class ic Normal \u0026amp; Visual Select inner part of a class Fuzzy Search Keybinds # Keymap Mode Description \u0026lt;leader\u0026gt;ff Normal Fuzzy find files in cwd \u0026lt;leader\u0026gt;fr Normal Fuzzy find recent files \u0026lt;leader\u0026gt;fs Normal Find strings in cwd \u0026lt;leader\u0026gt;fc Normal Find string under cursor in cwd \u0026lt;leader\u0026gt;fh Normal Fuzzy find files in harpoon marked list \u0026lt;leader\u0026gt;ft Normal Fuzzy find todos Harpoon Keybinds # Keymap Mode Description \u0026lt;leader\u0026gt;a Normal Add current buffer to harpoon marked list \u0026lt;leader\u0026gt;h Normal Toggle open/close harpoon marked list menu \u0026lt;C-u\u0026gt; Normal Go to next file on harpoon marked list \u0026lt;C-p\u0026gt; Normal Go to previous file on harpoon marked list \u0026lt;leader\u0026gt;1 Normal Go to first file on harpoon marked list \u0026lt;leader\u0026gt;2 Normal Go to second file on harpoon marked list \u0026lt;leader\u0026gt;3 Normal Go to third file on harpoon marked list \u0026lt;leader\u0026gt;4 Normal Go to fourth file on harpoon marked list Code Comments Keymaps # I use the default keymaps in Comment.nvim. To learn how to use them, check out their usage guide. Delimiter Pairs Keymaps # For swift manipulation of delimiter pairs, I rely on the default keymaps from nvim-surround. Explore their usage guide for insights into the diverse keymaps available. Code Completion # Keymap Mode Description \u0026lt;C-k\u0026gt; Insert Previous suggestion \u0026lt;C-j\u0026gt; Insert Next suggestion \u0026lt;C-b\u0026gt; Insert Scroll up \u0026lt;C-f\u0026gt; Insert Scroll down \u0026lt;C-Space\u0026gt; Insert Show completion suggestions \u0026lt;C-e\u0026gt; Insert Close completion window/menu \u0026lt;CR\u0026gt; Insert Select suggestion Language Server Keymaps # Keymap Mode Description gR Normal Show references and definition gD Normal Go to declaration gd Normal Show lsp definitions gi Normal Show lsp implementations gt Normal Show lsp type definitions \u0026lt;leader\u0026gt;ca Normal \u0026amp; Visual See available code actions \u0026lt;leader\u0026gt;rn Normal Smart rename \u0026lt;leader\u0026gt;D Normal Show diagnostics for file \u0026lt;leader\u0026gt;d Normal Show diagnostics for line \u0026lt;leader\u0026gt;[d Normal Jump to previous diagnostic in buffer \u0026lt;leader\u0026gt;]d Normal Jump to next diagnostic in buffer \u0026lt;leader\u0026gt;K Normal Show documentation for what is under cursor \u0026lt;leader\u0026gt;rs Normal Restart lsp Debugging Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;db Normal Toggle breaking point on line under cursor \u0026lt;leader\u0026gt;dC Normal Clear breakpoints \u0026lt;leader\u0026gt;ds Normal Start debugging session \u0026lt;leader\u0026gt;dc Normal Continue \u0026lt;leader\u0026gt;do Normal Step over \u0026lt;leader\u0026gt;di Normal Step into \u0026lt;leader\u0026gt;dO Normal Step out \u0026lt;leader\u0026gt;de Normal Close debugger and end debugging session \u0026lt;leader\u0026gt;dc Normal Continue Formatting Keymaps # Automatic formatting takes effect upon saving the current buffer, provided you have a formatter for the language in use. Keymap Mode Description \u0026lt;leader\u0026gt;mp Normal Format file \u0026lt;leader\u0026gt;mp Normal \u0026amp; Visual Format selected range Linting Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;l Normal Trigger linting for current file Markdown Preview Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;mdp Normal Start markdown preview (Browser tab) \u0026lt;leader\u0026gt;mdx Normal Stop markdown preview Git Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;gi Normal Git init \u0026lt;leader\u0026gt;ga Normal Stage current buffer \u0026lt;leader\u0026gt;gw Normal Save and stage current buffer in WT, checkout buffer in index \u0026lt;leader\u0026gt;gm Normal Rename and stage current buffer \u0026lt;leader\u0026gt;gs Normal Toggle open/close of status tab \u0026lt;leader\u0026gt;gd Normal Toggle open/close of diff tab \u0026lt;leader\u0026gt;gg Normal Open git graph Commits # Keymap Mode Description \u0026lt;leader\u0026gt;gcc Normal Populate git commit with message flag on command line \u0026lt;leader\u0026gt;gca Normal Amend the last commit \u0026lt;leader\u0026gt;gcm Normal populate git commit on command line Branches # Keymap Mode Description \u0026lt;leader\u0026gt;gbl Normal List all branches \u0026lt;leader\u0026gt;gbv Normal List all branches with their remote tracking branches \u0026lt;leader\u0026gt;gbo Normal Populate git branch on command line \u0026lt;leader\u0026gt;gba Normal Populate create branch and switch to it \u0026lt;leader\u0026gt;gbr Normal Populate rename branch \u0026lt;leader\u0026gt;gbd Normal Populate delete branch \u0026lt;leader\u0026gt;gbD Normal Populate force delete branch \u0026lt;leader\u0026gt;gco Normal Populate git checkout Stash # Keymap Mode Description \u0026lt;leader\u0026gt;gzz Normal Push stash (includes untracked files) from both WT and index \u0026lt;leader\u0026gt;gzw Normal Push stash (includes untracked files) from WT only \u0026lt;leader\u0026gt;gza Normal Apply top most stash \u0026lt;leader\u0026gt;gzA Normal Populate apply stash \u0026lt;leader\u0026gt;gzp Normal Pop top most stash \u0026lt;leader\u0026gt;gzP Normal Populate pop stash \u0026lt;leader\u0026gt;gzd Normal Drop top most stash \u0026lt;leader\u0026gt;gzD Normal Populate drop stash \u0026lt;leader\u0026gt;gzl Normal List all the stash \u0026lt;leader\u0026gt;gzo Normal Populate git stash Merge # Keymap Mode Description \u0026lt;leader\u0026gt;gmo Normal Populate git merge \u0026lt;leader\u0026gt;gmt Normal Open merge tool consider using diffview for solving conflicts \u0026lt;leader\u0026gt;gmr Normal Continue merging \u0026lt;leader\u0026gt;gmx Normal Abort merging Rebase # Keymap Mode Description \u0026lt;leader\u0026gt;gri Normal Populate interactive rebase \u0026lt;leader\u0026gt;grn Normal Populate interactive rebase with count from HEAD \u0026lt;leader\u0026gt;grr Normal Continue with current rebase \u0026lt;leader\u0026gt;grx Normal Abort current rebase \u0026lt;leader\u0026gt;gre Normal Edit todo list of current rebase \u0026lt;leader\u0026gt;gro Normal Populate git rebase Cherry Pick # Keymap Mode Description \u0026lt;leader\u0026gt;gyi Normal Populate git cherry-pick \u0026lt;leader\u0026gt;gyr Normal Continue with cherry-pick \u0026lt;leader\u0026gt;gyx Normal Abort cherry-pick Reset # Keymap Mode Description \u0026lt;leader\u0026gt;grh Normal Reset the last commit \u0026lt;leader\u0026gt;gRh Normal Hard reset the last commit \u0026lt;leader\u0026gt;grk Normal Populate reset with count from HEAD \u0026lt;leader\u0026gt;gRk Normal Populate hard reset with count from HEAD \u0026lt;leader\u0026gt;grO Normal Populate git reset Remote # Keymap Mode Description \u0026lt;leader\u0026gt;gps Normal Git push \u0026lt;leader\u0026gt;gPs Normal Git force push \u0026lt;leader\u0026gt;gpl Normal Git pull \u0026lt;leader\u0026gt;gPl Normal Git force pull \u0026lt;leader\u0026gt;gpu Normal Populate git push set upstream \u0026lt;leader\u0026gt;gra Normal Populate add remote \u0026lt;leader\u0026gt;grd Normal Populate remove remote \u0026lt;leader\u0026gt;grl Normal List all remotes \u0026lt;leader\u0026gt;gor Normal Populate git remote Git diffview # Keymap Mode Description \u0026lt;leader\u0026gt;gd Normal Toggle open/close diffview tab \u0026lt;leader\u0026gt;gfh Normal Toggle open/close file history of current buffer tab \u0026lt;leader\u0026gt;gh Normal Toggle open/close all commits/files history tab \u0026lt;leader\u0026gt;gR Normal Toggle open/close diff of HEAD and main branch diffview File Panel # Keymap Mode Description j, \u0026lt;Down\u0026gt; Normal Move cursor to next file entry k, \u0026lt;Up\u0026gt; Normal Move cursor to next file entry o, \u0026lt;2-LeftMouse\u0026gt; Normal Select current entry s Normal Stage/unstage selected entry S Normal Stage all entries U Normal Unstage all entries X Normal Restore entry to state on left side R Normal Update stats and entries on file list \u0026lt;S-Up\u0026gt; Normal Scroll up \u0026lt;S-Down\u0026gt; Normal Scroll down \u0026lt;C-j\u0026gt; Normal Open diff for next entry \u0026lt;C-k\u0026gt; Normal Open diff for previous entry gf Normal Open file in a split window \u0026lt;CR\u0026gt; Normal Open file in a new tab i Normal Toggle between list/tree views f Normal Flatten empty subdirectories in tree listing style \u0026lt;leader\u0026gt;e Normal Bring focus to the file panel diffview View Panel # Keymap Mode Description \u0026lt;C-j\u0026gt; Normal Open diff for next file \u0026lt;C-k\u0026gt; Normal Open diff for previous file \u0026lt;CR\u0026gt; Normal Open file in a previous tab \u0026lt;C-w\u0026gt;\u0026lt;C-f\u0026gt; Normal Open file in a split window \u0026lt;C-w\u0026gt;gf Normal Open file in a new tab \u0026lt;leader\u0026gt;e Normal Bring focus to the file panel \u0026lt;leader\u0026gt;b Normal Toggle file panel diffview File History Panel # Keymap Mode Description g! Normal Open option panel \u0026lt;C-A-d\u0026gt; Normal Open entry under cursor in a diffview zR Normal Open all folds zM Normal Close all folds j, \u0026lt;Down\u0026gt; Normal Move cursor to next entry k, \u0026lt;Up\u0026gt; Normal Move cursor to previous entry o, \u0026lt;CR\u0026gt;, \u0026lt;2-LeftMouse\u0026gt; Normal Select entry \u0026lt;C-j\u0026gt; Normal Select next entry \u0026lt;C-k\u0026gt; Normal Select previous entry gf Normal Go to file \u0026lt;C-w\u0026gt;\u0026lt;C-f\u0026gt; Normal Open file in a split window \u0026lt;C-w\u0026gt;gf Normal Open file in a new tab \u0026lt;leader\u0026gt;e Normal Bring focus to the file panel \u0026lt;leader\u0026gt;b Normal Toggle file panel ","date":"17-02-2024","permalink":"/posts/202402-my-neovim-keymaps/","section":"Posts","summary":"In this article, I\u0026rsquo;ll be sharing the keymaps I\u0026rsquo;ve configured within my Neovim setup to enhance simplicity and improve efficiency.\nBasic Keymaps # Keymap Mode Description \u0026lt;Space\u0026gt; N/A Leader key jk Insert Exit insert mode \u0026lt;leader\u0026gt;nh Normal Clear search highlights \u0026lt;C-a\u0026gt; Normal Select all + Normal Increment number under cursor - Normal Decrement number under cursor \u0026lt;leader\u0026gt;rw Normal Toggle Find \u0026amp; Replace \u0026lt;leader\u0026gt;rc Normal Toggle Find \u0026amp; Replace for word under cursor \u0026lt;C-z\u0026gt; Normal \u0026amp; Terminal Toggle FTerm terminal Window Management Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;sv Normal Split window vertically \u0026lt;leader\u0026gt;sh Normal Split window horizontally \u0026lt;leader\u0026gt;se Normal Make split windows equal width \u0026amp; height \u0026lt;leader\u0026gt;sm Normal Maximize/Minimize a split window \u0026lt;leader\u0026gt;sx Normal Close current slit window Tab Management Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;to Normal Open new tab \u0026lt;leader\u0026gt;tx Normal Close current tab \u0026lt;leader\u0026gt;tn Normal Go to next tab \u0026lt;leader\u0026gt;tp Normal Go to previous tab \u0026lt;leader\u0026gt;tf Normal Move current buffer to new tab Window Navigation Keymaps # Keymap Mode Description \u0026lt;C-h\u0026gt; Normal Move cursor to the window on the left \u0026lt;C-j\u0026gt; Normal Move cursor to the window below \u0026lt;C-k\u0026gt; Normal Move cursor to the window above \u0026lt;C-l\u0026gt; Normal Move cursor to the window on the right This works with my Tmux confnguration, so be sure to check it out as well.","title":"My Neovim Keymaps"},{"content":"","date":"17-02-2024","permalink":"/tags/neovim/","section":"Tags","summary":"","title":"neovim"},{"content":"","date":"11-02-2024","permalink":"/tags/arrays/","section":"Tags","summary":"","title":"arrays"},{"content":"Introduction # Arrays stand as one of the fundamental data structures, serving as a go-to choice for storing a sequence of items, be it strings, numbers, objects, or any other data type.\nThe effectiveness of arrays stems from their sequential storage in memory, as illustrated below:\nConsider an array of 5 integers, with the first item residing at memory address 100. Each subsequent item is placed in addresses like 104, 108, and so forth, given that integers in Java occupy 4 bytes each.\nThe efficiency of array indexing shines through with a constant runtime complexity of O(1). This simplicity arises from the direct calculation of memory addresses, free from loops or intricate logic. If your goal is to store a list of items and access them by index swiftly, arrays emerge as the optimal choice.\nLimitations of Arrays # Static Nature # Arrays, in Java and many other languages, have a fixed size. When you create an array, you have to decide how big it will be, and you can\u0026rsquo;t change it later. This becomes a problem when you don\u0026rsquo;t know exactly how many items you need. Guessing too high wastes memory because some spaces are never used. On the other hand, guessing too low means the array quickly gets filled up, and you have to resize it. Unfortunately, resizing has a cost, taking more time as the array gets bigger. This process is known as a runtime complexity of O(n).\nRemoval Operations # While removing the last item from an array is easy and quick (O(1) time), things get more complicated when removing an item at the beginning. In this case, all items to the right of the removed one need to shift to the left 1 position to fill the gap. The bigger the array, the more time it takes to do this. As a result, the worst-case runtime complexity for removing an item at the beginning is O(n).\nUnderstanding these details helps developers make smart choices about using arrays, thinking about both their benefits and drawbacks when creating efficient algorithms and data structures.\nWorking with Arrays in Java # When working with arrays in Java, you declare them using the following syntax:\nint[] variable_name = new int[3]; This statement declares an array that will store items of the integer type, with a size of 3, meaning it can only store 3 items. The variable_name is a variable that points to the memory address of the array.\nTo print the value of variable_name, it will display the array hash code along with the array type, i.e., the data type the array is storing.\npublic class Main{ public static void main(String[] args) { int[] variable_name = new int[3]; System.out.println(variable_name); } } Output: The [ Indicates its an array the I is the data type and the value after the @ is the array hash code.\nTo print the actual items in the array, you can use the Arrays class from the java.util package and the toString method to convert the array to a string.\nimport java.util.Arrays; public class Main{ public static void main(String[] args) { int[] variable_name = new int[3]; System.out.println(Arrays.toString(variable_name)); } } This will print [0, 0, 0] because when declaring arrays using this method, the array is instantiated with default values. For integers, the default value is 0.\nTo change the values of items in the array, you use their index as shown below:\nimport java.util.Arrays; public class Main{ public static void main(String[] args) { int[] variable_name = new int[3]; variable_name[0] = 10; variable_name[1] = 20; variable_name[2] = 30; System.out.println(Arrays.toString(variable_name)); } } The line variable_name[0] = 10; sets the value of the first item to 10, and so on.\nIf you know the items you are going to store in the array ahead of time, there is a shorter and cleaner way to initialize the array:\nimport java.util.Arrays; public class Main{ public static void main(String[] args) { int[] variable_name = { 10, 20, 30 }; System.out.println(Arrays.toString(variable_name)); System.out.println(variable_name.length); } } This method declares and initializes the array with the values provided in the braces, setting the size of the array to the number of items in the braces, which, in this case, is 3 and cannot be changed.\nIf you want to add another item to the array, you need to create a new array with a larger size, then copy the items from the old array and add the new item.\nimport java.util.Arrays; public class Main{ public static void main(String[] args) { int[] variable_name = { 10, 20, 30 }; int[] numbers = new int[4]; for (int i = 0; i \u0026lt; variable_name.length; i++) numbers[i] = variable_name[i]; numbers[3] = 40; System.out.println(Arrays.toString(variable_name)); } } This limitation of arrays in Java leads to the need for dynamic arrays or lists. If you want to work with lists that grow or shrink automatically, you would use linked lists.\nExercise # As you\u0026rsquo;ve learned, arrays in Java are static, meaning they have a fixed size that cannot be changed. In this section, we will create an Array class that behaves like a dynamic array. As we add new items, it will automatically grow, and as we remove items, it will automatically shrink.\npublic class Main { public static void main(String[] args) { Array numbers = new Array(3); // Create an instance of the Array class with an initial size of 3 // Adding items to the array numbers.insert(10); numbers.insert(20); numbers.insert(30); // Displaying the items in the array System.out.println(\u0026#34;Original array:\u0026#34;); numbers.print(); // Expected output: 10, 20, 30 on separate lines // Adding an item beyond the initial size (which was 3) numbers.insert(40); // Displaying the updated array after insertion System.out.println(); System.out.println(\u0026#34;Updated array - after insertion:\u0026#34;); numbers.print(); // Expected output: 10, 20, 30, 40 on separate lines // Removing an item at a specified index (0 in this case) numbers.removeAt(0); // This will remove the first item (10) // Displaying the updated array after removal System.out.println(); System.out.println(\u0026#34;Updated array - after removing index 0:\u0026#34;); numbers.print(); // Expected output: 20, 30, 40 on separate lines // Finding the index of an item (30 in this case) System.out.println(); System.out.println(\u0026#34;Index of 30 in the updated array:\u0026#34;); System.out.println(numbers.indexOf(30)); // Expected output: 1 System.out.println(numbers.indexOf(100)); // Expected output: -1 } } Creating the Dynamic Array Class # public class Array { private int[] items; // Array to store items private int count; // Number of items in the array // Constructor initializes the array based on the specified length public Array(int length) { items = new int[length]; } // Insert method adds an item to the array, dynamically resizing if needed public void insert(int item) { if (items.length == count) { // Resize the array by creating a new one with double the size int[] newItems = new int[count * 2]; // Copy existing items to the new array for (int i = 0; i \u0026lt; count; i++) newItems[i] = items[i]; items = newItems; // Update the array reference } items[count++] = item; // Add the new item at the end then increment the item count } // RemoveAt method removes an item at a given index, maintaining array integrity public void removeAt(int index) { if (index \u0026lt; 0 || index \u0026gt;= count) throw new IllegalArgumentException(\u0026#34;Invalid index\u0026#34;); // Shift items to the left to fill the gap for (int i = index; i \u0026lt; count - 1; i++) items[i] = items[i + 1]; count--; // Update the item count } // IndexOf method finds the index of a specified item public int indexOf(int item) { for (int i = 0; i \u0026lt; count; i++) if (items[i] == item) return i; // Return the index when the item is found return -1; // Return -1 if the item is not in the array } // Print method displays the items in the array public void print() { for (int i = 0; i \u0026lt; count; i++) System.out.println(items[i]); } } Testing the Dynamic Array # Now, let\u0026rsquo;s put the dynamic array to the test in the Main class.\npublic class Main { public static void main(String[] args) { Array numbers = new Array(3); // Adding items to the array numbers.insert(10); numbers.insert(20); numbers.insert(30); numbers.insert(40); // Displaying the items in the array after insertion System.out.println(\u0026#34;Updated array - after insertion:\u0026#34;); numbers.print(); // Removing an item at a specified index (0 in this case) numbers.removeAt(0); // Displaying the updated array after removal System.out.println(\u0026#34;Updated array - after removing index 0:\u0026#34;); numbers.print(); // Finding the index of an item (30 in this case) System.out.println(\u0026#34;Index of 30 in the updated array:\u0026#34;); System.out.println(numbers.indexOf(30)); System.out.println(numbers.indexOf(100)); } } In this implementation, the Array class dynamically adjusts its size, providing a flexible and efficient solution for managing arrays in Java.\nDynamic Arrays in Java # In our previous exercise, we acquired knowledge on constructing dynamic arrays, offering flexibility in managing data structures. Now, let\u0026rsquo;s delve into Java\u0026rsquo;s specific implementations of dynamic arrays: Vector and ArrayList. These implementations are vital components of the java.util package.\n1. Vector # The Vector class is a dynamic array that exhibits growth by 100% of its size when reaching capacity. This means that when the array is full, its size doubles to accommodate more elements efficiently.\n2. ArrayList # The ArrayList class, another dynamic array in Java, follows a growth strategy by 50% of its size when the array becomes full. This approach ensures a more conservative increase in size, balancing efficiency and memory utilization.\nExploring the ArrayList Class # Let\u0026rsquo;s take a quick tour of the ArrayList class with a code snippet:\nimport java.util.ArrayList; public class Main { public static void main(String[] args) { // Create an ArrayList of Integers ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(10); list.add(20); list.add(30); // Display the ArrayList System.out.println(list); // Output: [10, 20, 30] // Remove an element at index 0 list.remove(0); System.out.println(list); // Output: [20, 30] // Find the index of an element (e.g., 20) System.out.println(list.indexOf(20)); // Output: 0 // Add another 20 to the list list.add(20); System.out.println(list); // Output: [20, 30, 20] // Find the last occurrence of an element (e.g., 20) System.out.println(list.lastIndexOf(20)); // Output: 2 // Check if the list contains a specific element (e.g., 30) list.contains(30); // Returns a boolean value // Get the size of the ArrayList list.size(); // Convert the ArrayList to a regular array list.toArray(); } } This tour provides a glimpse into the versatility of the ArrayList class, showcasing its dynamic growth strategy, methods for manipulation, and additional utility functions. Understanding these dynamic array implementations is essential for effective data management in Java.\nConclusion # In conclusion, understanding arrays in Java is a foundational step in mastering data structures. Arrays provide a simple yet powerful way to organize and access data sequentially in memory, offering quick look-up times with a constant runtime complexity of O(1). However, it\u0026rsquo;s crucial to be aware of their limitations, particularly their static nature, requiring predefined sizes and potential inefficiencies when resizing.\nReferences # Mosh Hamedani. Ultimate Data Structures \u0026amp; Algorithms: Part 1 JavaTpoint - JavaTpoint\u0026rsquo;s comprehensive tutorials on \u0026ldquo;Array in Data Structure\u0026rdquo; in Java. ","date":"11-02-2024","permalink":"/posts/202402-arrays/","section":"Posts","summary":"Introduction # Arrays stand as one of the fundamental data structures, serving as a go-to choice for storing a sequence of items, be it strings, numbers, objects, or any other data type.","title":"Arrays Data Structure"},{"content":"Introduction # Big O notation is a mathematical tool that helps describe the limiting behavior of a function as its input approaches infinity. It is commonly used in computer science to analyze and compare the efficiency of algorithms. In this article, we will explore the basics of Big O notation and its application in understanding algorithmic performance.\nUnderstanding Big O Notation # Big O notation, denoted as O(f(n)), provides an upper bound on the growth rate of a function concerning the size of its input. In simpler terms, it describes how the runtime or space requirements of an algorithm scale with the size of the input.\nO(1) - Constant Time Complexity # Consider the following Java snippet:\npublic class Main { public void log(int[] numbers) { // O(1) System.out.println(numbers[0]); } } This snippet has a constant time complexity O(1) because the execution time remains constant regardless of the size of the input array. Adding more print statements or operations within the method does not change its constant time nature.\npublic class Main { public void log(int[] numbers) { // O(2) System.out.println(numbers[0]); System.out.println(numbers[0]); } } We have two operations, both running in constant time, so the runtime complexity of the method is still O(1). In this method, the size of the input does not matter; the method will always execute in constant time.\nO(n) - Linear Time Complexity # Linear time complexity, denoted as O(n), describes algorithms whose runtime grows proportionally with the size of the input. Let\u0026rsquo;s explore some examples to better understand this concept.\nBasic Linear Operation # Consider the following Java code:\npublic class Main { public void log(int[] numbers) { // O(n) for (int i = 0; i \u0026lt; numbers.length; i++) System.out.println(numbers[i]); } } In this example, the method iterates through each element in the numbers array, and the time complexity is linear O(n). The larger the input array, the longer the runtime.\nConstant-Time Operations in Linear Context # Now, let\u0026rsquo;s examine a scenario where we add constant-time operations before and after the loop:\npublic class Main { public void log(int[] numbers) { // O(1 + n + 1) -\u0026gt; O(2+n) -\u0026gt; O(n) System.out.println(); // O(1) for (int i = 0; i \u0026lt; numbers.length; i++) // O(n) System.out.println(numbers[i]); System.out.println(); // O(1) } } Despite the added constant-time operations, the overall time complexity remains O(n). This illustrates the principle that constants are typically dropped in Big O analysis.\nMultiple Linear Loops # Let\u0026rsquo;s consider a scenario with two loops:\npublic class Main { public void log(int[] numbers) { // O(n + n) -\u0026gt; O(2n) -\u0026gt; O(n) for (int number : numbers) // O(n) System.out.println(number); for (int number : numbers) // O(n) System.out.println(number); } } The presence of two linear operations still results in linear time complexity O(n), as constants are dropped in Big O notation.\nLinear Time Complexity with Multiple Parameters # Adding more parameters to a method does not change its fundamental linear time complexity:\npublic class Main { public void log(int[] numbers, String[] names) { // O(n + m) -\u0026gt; O(n) for (int number : numbers) // O(n) System.out.println(number); for (String name : names) // O(m) System.out.println(name); } } In this case, the overall runtime complexity is O(n), as we focus on the parameter that has linear growth.\nO(n2) - Quadratic Time Complexity # Quadratic time complexity, denoted as O(n²), characterizes algorithms that exhibit a growth rate proportional to the square of the input size. This often occurs with nested loops, where each iteration contributes to the overall growth. Let\u0026rsquo;s delve into examples to gain a clearer understanding.\nNested Loop Scenario # Consider the following Java code:\npublic class Main { public void log(int[] numbers) { // O(n * n) -\u0026gt; O(n^2) for (int first : numbers) // O(n) for (int second : numbers) // O(n) System.out.println(first + \u0026#34;, \u0026#34; + second); } } In this example, the outer loop iterates through each element in the numbers array, and for each iteration of the outer loop, the inner loop also traverses the entire array. The result is a quadratic time complexity of O(n²).\nAlgorithms that run in O(n²) run slower than algorithms that run in O(n)\nAdditional Operations in Quadratic Context # Let\u0026rsquo;s examine a scenario where we have additional operations before or after the nested loop:\npublic class Main { public void log(int[] numbers) { // O(n + n^2) -\u0026gt; O(n^2) for (int number : numbers) // O(n) System.out.println(number); for (int first : numbers) // O(n) for (int second : numbers) // O(n) System.out.println(first + \u0026#34;, \u0026#34; + second); } } In this example, the first loop has a time complexity of O(n) as it iterates through each element in the numbers array. The nested loop, however, has a quadratic time complexity of O(n²), as it iterates through each combination of elements in the array. When we express the overall time complexity as O(n + n²), we recognize that the dominant factor is the quadratic term n².\nThe rationale for dropping the linear term n is rooted in the principle of Big O notation, where we focus on the dominant term that contributes the most to the growth rate. In this context, as the size of the input n becomes larger, the impact of the quadratic term n² becomes significantly more substantial, overshadowing the linear term. Therefore, for the purpose of understanding how the cost of the algorithm increases relative to its input size, we simplify the expression to O(n²).\nImpact of Nested Loops on Growth Rate # What if we had nested loops within the original nested loop:\npublic class Main { public void log(int[] numbers) { // O(n * n * n) -\u0026gt; O(n^3) for (int first : numbers) // O(n) for (int second : numbers) // O(n) for (int third : numbers) // O(n) System.out.println(first + \u0026#34;, \u0026#34; + second + \u0026#34;, \u0026#34; + third); } } In this case, the time complexity becomes cubic O(n³), showcasing how the growth rate accelerates with additional nested loops.\nAlgorithms that run in O(n³) are far slower than those that run in O(n²) and O(n). The exponential increase in computational cost makes algorithms with cubic time complexity less scalable and less efficient compared to their quadratic and linear counterparts. This underscores the importance of considering the time complexity when designing algorithms for optimal performance.\nO(log n) - Logarithmic Time Complexity # Another growth rate we are going to talk about is the logarithmic growth, denoted as O(log n). Here is a logarithmic curve for better visualization:\nCompare it with a linear curve:\nThe linear curve grows at the same rate, while the logarithmic curve slows down at some point. An algorithm that runs in logarithmic time is more efficient and more scalable than an algorithm that runs in linear or quadratic time.\nExample # Let\u0026rsquo;s consider an algorithm with logarithmic time complexity:\nAssuming we have an array of sorted numbers from 1 to 10 and we want to find the number 10. We can implement the Binary Search algorithm, which runs in logarithmic time.\npublic class Main { public int binarySearch(int[] sortedArray, int target) { int low = 0; int high = sortedArray.length - 1; while (low \u0026lt;= high) { int mid = (low + high) / 2; if (sortedArray[mid] == target) { return mid; // Target found } else if (sortedArray[mid] \u0026lt; target) { low = mid + 1; // Search in the right half } else { high = mid - 1; // Search in the left half } } return -1; // Target not found } } In this example, the Binary Search algorithm efficiently narrows down the search space in each iteration. The key advantage comes from the fact that it operates on a sorted array. By continually halving the search space, it minimizes the number of comparisons needed to find the target element. In contrast, a linear search would require iterating through all items in the array, and in the worst case scenario, the target item could be the last element. This linear approach becomes increasingly inefficient as the size of the dataset grows.\nThe logarithmic time complexity O(log n) of the Binary Search algorithm makes it significantly more efficient, especially when dealing with large datasets, as it avoids unnecessary iterations and quickly converges to the target element.\nO(2n) - Exponential Time Complexity # Another type of growth is exponential growth, denoted as O(2ⁿ).\nThe exponential growth is the opposite of logarithmic growth, where the curve grows faster and faster.\nThe logarithmic curve slows down as the input size grows, but the exponential curve grows faster and faster. An algorithm that runs in exponential time is not scalable and would become very slow very soon.\nExample # Let\u0026rsquo;s explore an algorithm with exponential time complexity:\npublic class Main { public int fibonacci(int n) { if (n \u0026lt;= 1) { return n; } else { return fibonacci(n - 1) + fibonacci(n - 2); } } } In this example, the Fibonacci algorithm, which calculates Fibonacci numbers recursively, exhibits exponential time complexity O(2ⁿ). As the input value increases, the number of recursive calls grows exponentially, leading to a rapid increase in computational cost.\nExponential time complexity is not scalable for large inputs, making algorithms with this complexity impractical for certain applications.\nSpace Complexity # We\u0026rsquo;ve seen how Big O Notation helps describe the runtime complexity of algorithms. Ideally, we want our algorithms to be fast, scalable, and use minimal memory. However, this ideal is rarely achieved. Most often, we must make trade-offs between saving time and saving space.\nSometimes we have extra space, allowing us to optimize algorithms for speed and scalability. Other times, especially when building apps for small devices, space is limited, and we prioritize optimizing for space over scalability.\nSo, we need a way to talk about how much space an algorithm requires, and that\u0026rsquo;s where we use the Big O Notation again.\nO(x) # public class Main { public void greet(String[] names) { // O(1) space for (int i = 0; i \u0026lt; names.length; i++) System.out.println(\u0026#34;Hi\u0026#34; + names[i]); } } In this greet method, the loop variable i is independent of the size of the input. Whether the array has 10 or a million items, the method will only allocate a constant amount of memory for the loop variable, representing O(1) space complexity.\nWhat if we declare a copy string array and initialize it as shown below:\npublic class Main { public void greet(String[] names) { // O(n) space String[] copy = new String[names.length]; for (int i = 0; i \u0026lt; names.length; i++) copy[i] = names[i]; } } Conclusion # The growth rates we\u0026rsquo;ve explored are common in algorithmic analysis. While they represent just a subset of possibilities, they capture scenarios frequently encountered.\nIn this series, we\u0026rsquo;ll mainly focus on runtime complexity, tackling its intricate aspects. Nevertheless, it\u0026rsquo;s crucial to also consider space complexity in your algorithms, especially in situations where memory is limited. As you navigate algorithmic challenges, think creatively about preserving memory.\nReferences # Mosh Hamedani. Ultimate Data Structures \u0026amp; Algorithms: Part 1 Wikipedia - Big O Notation ","date":"10-02-2024","permalink":"/posts/202402-big-o-notation/","section":"Posts","summary":"Introduction # Big O notation is a mathematical tool that helps describe the limiting behavior of a function as its input approaches infinity. It is commonly used in computer science to analyze and compare the efficiency of algorithms.","title":"Big O Notation: Understanding Algorithmic Efficiency"},{"content":"","date":"10-02-2024","permalink":"/tags/big-o-notation/","section":"Tags","summary":"","title":"big-o-notation"},{"content":"Introduction # Developing Java code in Neovim can be a seamless experience with the right Language Server Protocol (LSP) setup. In this blog post, we will explore how to enhance your Neovim environment for Java development by configuring nvim-jdtls. This plugin, available at nvim-jdtls, offers a comprehensive set of features tailored for Java, addressing challenges such as navigating to the definition of methods and classes outside your project.\nBefore we proceed, ensure you\u0026rsquo;ve checked out my Neovim configuration post, which complements this setup:\nMy Neovim Configuration Setup Guide 16-01-2024\u0026middot;949 words\u0026middot;5 mins lua neovim Prerequisites # Neovim version \u0026gt;= 0.6.0\nVerify your Neovim version using:\nnvim --version Java runtime environment 17 and above\nInstall the desired Java version, ensuring it is 17 or above. For example, to install OpenJDK version 21:\nsudo apt install openjdk-21-jdk Set the JAVA_HOME environment variable to point to the JDK or JRE directory. Identify the correct path using:\nsudo update-alternatives --config java Set JAVA_HOME in your .bashrc or .zshrc:\nexport JAVA_HOME=/path/to/openjdk-21 For example:\nexport JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64 eclipse.jdt.ls\nDownload and extract a snapshot build from http://download.eclipse.org/jdtls/snapshots/:\nwget https://download.eclipse.org/jdtls/snapshots/jdt-language-server-1.31.0-202312211634.tar.gz \u0026amp;\u0026amp; sudo tar -C /usr/local -xzf jdt-language-server-1.31.0-202312211634.tar.gz java-debug To debug java programs, load the java-debug extension. Install it on your neovim data folder ~/.local/share/nvim using the following commands\ngit clone https://github.com/microsoft/java-debug.git ~/.local/share/nvim/java-debug cd ~/.local/share/nvim/java-debug ./mvnw clean install Installing plugins # 1. nvim-jdtls # Install the plugin using your preferred plugin manager. If using Lazy, add the following line to your init.lua file and install with :Lazy:\n\u0026#34;mfussenegger/nvim-jdtls\u0026#34;, -- java lsp 2. nvim-dap # Install nvim-dap using your preferred plugin manager. Check out my nvim-dap configuration which provides a user-friendly UI as well as key mappings for debugging.\n3. jdtls LSP # Install jdtls lsp using Mason by initiating mason with :Mason and proceeding with the installation. Check out my Mason configuration if you haven\u0026rsquo;t setup Mason. Mason is just a plugin for managing LSPs, linters, formatters, and DAPs.\nConfiguration # 1. Avoid confict between nvim-lspconfig and nvim-jdtls # Skip this step if you are not using nvim-lspconfig.\nTo avoid conficts, ensure you do not run nvim-lspconfig and nvim-jdtls simultaneously. Add the following setup_handler configuration to your nvim-lspconfig (in my case it\u0026rsquo;s ~/.config/nvim/lua/justice/plugins/lsp/lspconfig.lua):\n-- empty function to ignore jdtls local noop = function() end require(\u0026#34;mason-lspconfig\u0026#34;).setup_handlers({ function(server_name) lspconfig[server_name].setup({ on_attach = on_attach, capabilities = capabilities, }) end, [\u0026#34;jdtls\u0026#34;] = noop, }) 2. jdtls configuration # Create a ~/.config/nvim/ftplugin/java.lua file with the following code for jdtls configuration:\nlocal jdtls_bin = vim.fn.stdpath(\u0026#34;data\u0026#34;) .. \u0026#34;/mason/bin/jdtls\u0026#34; local keymap = vim.keymap local opts = { noremap = true, silent = true } local lsp_attach = function(client, bufnr) require(\u0026#34;jdtls.dap\u0026#34;).setup_dap_main_class_configs() -- Discover main classes for debugging opts.buffer = bufnr -- set keybinds. Copied my lspconfig keybinds here end local config = { cmd = { jdtls_bin }, root_dir = vim.fs.dirname(vim.fs.find({ \u0026#34;gradlew\u0026#34;, \u0026#34;.git\u0026#34;, \u0026#34;mvnw\u0026#34; }, { upward = true })[1]), on_attach = lsp_attach, init_options = { bundles = { vim.fn.glob(vim.fn.stdpath(\u0026#34;data\u0026#34;) .. \u0026#34;/java-debug/com.microsoft.java.debug.plugin/target/com.microsoft.java.debug.plugin-*.jar\u0026#34;, 1), }, }, } require(\u0026#34;jdtls\u0026#34;).start_or_attach(config) 3. nvim-dap configuration # Given that you have already installed nvim-dap, nvim-jdtls provides integration with nvim-dap, so you don\u0026rsquo;t need to configure Java debug adapters; nvim-jdtls adds that for you automatically. The only thing you\u0026rsquo;ll need to do is add a java configuration for debugging. Check out their wiki for more details. Add the following configuration to your nvim-dap plugin configuration file\nrequire(\u0026#34;dap\u0026#34;).configurations = { java = { { type = \u0026#34;java\u0026#34;, name = \u0026#34;Debug\u0026#34;, request = \u0026#34;launch\u0026#34;, program = \u0026#34;${file}\u0026#34;, }, }, -- configurations for other languages } My configuration files # Explore my configuration files by visiting lspconfig.lua, java.lua and dap.lua.\nConclusion # Kudos on completing the setup! Your Neovim environment is now finely tuned for Java development with the configured Java LSP. Wishing you smooth coding sessions ahead - Happy coding!\n","date":"05-02-2024","permalink":"/posts/202402-configuring-java-lsp-for-neovim-with-nvim-jdtls/","section":"Posts","summary":"Introduction # Developing Java code in Neovim can be a seamless experience with the right Language Server Protocol (LSP) setup. In this blog post, we will explore how to enhance your Neovim environment for Java development by configuring nvim-jdtls.","title":"Configuring Java LSP, and Debugger for Neovim with nvim-jdtls"},{"content":"","date":"05-02-2024","permalink":"/tags/nvim-jdtls/","section":"Tags","summary":"","title":"nvim-jdtls"},{"content":"","date":"05-02-2024","permalink":"/tags/nvim-lspconfig/","section":"Tags","summary":"","title":"nvim-lspconfig"},{"content":"I\u0026rsquo;m a fullstack software developer based in Kenya. I\u0026rsquo;m proficient in Python, Django, Javascript, Node.js, React, React Native and Golang.\nFeel free to reach out.\n","date":"01-02-2024","permalink":"/about/","section":"Justice Nyaga","summary":"I\u0026rsquo;m a fullstack software developer based in Kenya. I\u0026rsquo;m proficient in Python, Django, Javascript, Node.js, React, React Native and Golang.\nFeel free to reach out.","title":"About Me"},{"content":"Here are a few past projects I\u0026rsquo;ve worked on:\nLogo Title Description Link Proshop A fake shopping app built on React. The app utilizes proshop_api (Django REST API) sitegithub Proshop-Api An e-commerce REST API crafted with Django and Django Rest Framework, incorporating diverse shopping app features. sitegithub Bridge School A high school management system web application github DoneWithIt A faux native app marketplace designed for selling items you no longer need. github ","date":"31-01-2024","permalink":"/projects/","section":"Justice Nyaga","summary":"Here are a few past projects I\u0026rsquo;ve worked on:\nLogo Title Description Link Proshop A fake shopping app built on React. The app utilizes proshop_api (Django REST API) sitegithub Proshop-Api An e-commerce REST API crafted with Django and Django Rest Framework, incorporating diverse shopping app features.","title":"Projects"},{"content":"Introduction # Welcome to this comprehensive guide on installing and configuring Ubuntu Desktop environment on Windows Subsystem for Linux 2 (WSL2). Enhance your development environment and streamline your coding experience with this step-by-step walkthrough.\nThis post assumes that you have already installed Ubuntu within WSL2. If not, please do install it before proceeding.\nStep 1: Install Ubuntu Desktop and Mesa-utils # Begin by installing the Ubuntu Desktop and mesa-utils packages:\nsudo apt update sudo apt install ubuntu-desktop mesa-utils Troubleshooting for \u0026ldquo;Transport endpoint is not connected\u0026rdquo; error # If you encounter the error \u0026ldquo;Transport endpoint is not connected\u0026rdquo; during the setup, perform the following troubleshooting steps:\nPress Ctrl + C to skip packages with the error. Run the following commands: sudo mv /etc/acpi/events /etc/acpi/events.bak sudo ln -s /dev/null /etc/systemd/system/acpid.service sudo ln -s /dev/null /etc/systemd/system/acpid.path Run the following command to reconfigure the unpacked packages that were skipped on the previous step.\nsudo dpkg --configure -a Step 2: Set Up Environment Variables # Configure environment variables for persistent settings. It\u0026rsquo;s recommended to add these to your .bashrc or .zshrc:\nexport DISPLAY=\u0026#34;$(grep nameserver /etc/resolv.conf | sed \u0026#39;s/nameserver //\u0026#39;):0\u0026#34; export LIBGL_ALWAYS_INDIRECT=0 Step 3: Install VcXsrv on Windows # On the Windows side, install VcXsrv. After installation, choose the following setup options:\nMultiple windows\nDisplay number: 0\nStart no client\nCheck everything on Extra settings, that is, clipboard, primary selection, Native opengl, Disable access control\nYou can save the configuration for future use\nClick finish to start the server\nStep 4: Verify Installation with xeyes # Ensure VcXsrv is running and test the setup by opening xeyes app or any other installed desktop app such as firefox on your WSL terminal:\nxeyes Conclusion # The successful opening of the xeyes app indicates that you have seamlessly set up the Ubuntu Desktop environment on WSL2. Happy coding!\n","date":"31-01-2024","permalink":"/posts/202401-setting-up-ubuntu-desktop-environment-on-wsl2/","section":"Posts","summary":"A comprehensive guide to installing and configuring the Ubuntu Desktop environment on Windows Subsystem for Linux 2 (WSL2). Enhance your development environment and streamline your coding experience with this step-by-step walkthrough.","title":"Setting up Ubuntu Desktop Environment on WSL2"},{"content":"","date":"31-01-2024","permalink":"/tags/ubuntu/","section":"Tags","summary":"","title":"ubuntu"},{"content":"","date":"31-01-2024","permalink":"/tags/ubuntu-desktop/","section":"Tags","summary":"","title":"ubuntu-desktop"},{"content":"","date":"31-01-2024","permalink":"/tags/vcxsrv/","section":"Tags","summary":"","title":"vcxsrv"},{"content":"","date":"31-01-2024","permalink":"/tags/wsl2/","section":"Tags","summary":"","title":"wsl2"},{"content":"Introduction # Tmux is a terminal multiplexer; it allows multiple terminal sessions to be accessed from a single window.\nIn this article, we\u0026rsquo;ll walk through my Tmux setup that is designed for efficient integration with Neovim.\nScreenshots # Configuration # Follow these steps to set up Tmux:\nInstall Tmux:\nIf Tmux is not already installed on your system, you can install it using your package manager. For example, on Debian-based systems, run:\nsudo apt-get install tmux Verify the installation by checking the Tmux version:\ntmux -V Retrieve My Configuration File:\nDownload my Tmux configuration file into your home directory using the following command:\nwget https://raw.githubusercontent.com/justicenyaga/my_nvim_config/master/.tmux.conf -O ~/.tmux.conf Install Tmux Plugin Manager (tpm):\nClone the Tmux Plugin Manager repository to ~/.tmux/plugins/ using:\ngit clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm Create a Tmux session:\nStart a new Tmux session.\ntmux new -s SessionName This should create a session and attach you to the created session.\nReload the Tmux configuration file:\nPress your Tmux prefix key (my configuration uses Ctrl + N) followed by r to reload the configuration file:\n\u0026lt;C-n\u0026gt;r On the configuration file, replace C-n with a prefered key bind to override the default prefix key bind, on the following lines:\nset -g prefix C-n bind-key C-n send-prefix Install Tmux plugins:\nWhile inside a Tmux session, install plugins by pressing your Tmux prefix key followed by I (uppercase):\n\u0026lt;C-n\u0026gt;I Again, replace \u0026lt;C-n\u0026gt; with your configured prefix key bind. That\u0026rsquo;s it! Your Tmux environment is now configured with the specified settings and plugins. Customize further based on your preferences.\nUsage # Normal Keymaps # Keybind Description C-n Prefix key prefix + | Vertical split prefix + - Horizontal split prefix + r Reload configuration prefix + j/k/l/h Resize panes prefix + m Maximize pane Copy Mode Keymaps # Keybind Description prefix + [ Enter copy mode v Start selection y Copy selection q Exit copy mode Remember to customize these keybinds further based on your preferences and workflow!\n","date":"20-01-2024","permalink":"/posts/202401-my-tmux-configuration/","section":"Posts","summary":"Introduction # Tmux is a terminal multiplexer; it allows multiple terminal sessions to be accessed from a single window.\nIn this article, we\u0026rsquo;ll walk through my Tmux setup that is designed for efficient integration with Neovim.","title":"My Tmux Configuration"},{"content":"","date":"20-01-2024","permalink":"/tags/tmux/","section":"Tags","summary":"","title":"tmux"},{"content":"","date":"16-01-2024","permalink":"/tags/lua/","section":"Tags","summary":"","title":"lua"},{"content":"Introduction # This article is a walkthrough on how to configure my neovim setup. My setup has been configured for working with Javascript, React, Python, Golang, and Java.\nScreenshots # Features # Plugins managed with lazy.nvim Syntax highlighting with treesitter Code snippets and code auto-completion via nvim-cmp LSPs installed with Mason and configured using lspconfig Code formatting with conform Debuggers installed and configured with nvim-dap Terminal integration with fterm Fuzzy searching with telescope Git decorations to reflect changes in files using gitsigns.nvim Git integration via fugitive Git branch/commit/diff viewing via diffview Beautiful and powerful git graph via vim-flog friendly-snippets and VS Code ES7 snippets Faster code commenting with Comment.nvim Quicky add/delete/change delimiter pairs with nvim-surround Fold management with nvim-ufo Beautiful status bar via lualine nightfly colorscheme nvim-tree file explorer with nvim-web-devicons for the icons Beautiful UI via dressing.nvim Animated GUI notifications via nvim-notify Tabs and Splits navigation via vim-tmux-navigator Prerequisites # Before diving into the configuration, ensure you have the following prerequisites installed:\n1. Ensure Neovim v0.9+: # Ensure that you have Neovim version 0.9 or above installed. Check your Neovim version using:\nnvim --version 2. Install python3-venv: # Install the python3-venv package using the following command:\nsudo apt install python3-venv 3. Node Packages: # Install neovim and tree-sitter node packages by running the following command:\nnpm i -g neovim tree-sitter 4. pynvim Package: # Install the pynvim package using pip:\npython3 -m pip install -U pynvim Ensure that the python command points to python3 by adding the following alias on your .bashrc or .zshrc:\nalias python=python3 5. Telescope requirements: # For telescope to work without any issues, you need to have both ripgrep and fd packages. Install them using:\nsudo apt install ripgrep fd-find 6. Optional: For GoDevs: # If you haven\u0026rsquo;t installed Go, use the official installation guide on how to go about it.\nAfter installation, set up the required environment variables in your shell configuration file (e.g., .bashrc or .zshrc):\nexport GOPATH=~/go export GOROOT=/usr/local/go export PATH=$PATH:/usr/local/go/bin export PATH=$PATH:~/go/bin Install Go Language Server (gopls) with the following command:\ngo install golang.org/x/tools/gopls@latest 7. Optional: Java # For Java developer, follow the following steps:\nEnsure you are running JRE 17 and above java --version Ensure JAVA_HOME environment variable points to the JDK directory. Identify the correct path using: sudo update-alternatives --config java Set JAVA_HOME in your .bashrc or .zshrc: export JAVA_HOME=/path/to/openjdk For example: export JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64 Download and extract a snapshot build from http://download.eclipse.org/jdtls/snapshots/ using: wget https://download.eclipse.org/jdtls/snapshots/jdt-language-server-1.31.0-202312211634.tar.gz \u0026amp;\u0026amp; sudo tar -C /usr/local -xzf jdt-language-server-1.31.0-202312211634.tar.gz 8. Clone Configuration Repo: # Clone my Neovim configuration repository to ~/.config/nvim:\ngit clone https://github.com/justicenyaga/my_nvim_config.git ~/.config/nvim 9. Optional: win32yank for WSL # For WSL users, install win32yank for clipboard interaction between Windows and WSL by following these steps:\nDownload win32yank binary:\nVisit https://github.com/equalsraf/win32yank/releases to download the win32yank binary. Copy it to /usr/local/bin:\nAfter downloading the binary, copy it to the /usr/local/bin directory. Add execution permissions:\nSet execution permissions for win32yank.exe using the following command: chmod +x win32yank.exe Uninstall xclip and xsel:\nTo avoid potential conflicts, uninstall xclip and xsel if they are installed on your system as they would be used by default. sudo apt remove xclip sudo apt remove xsel # if it exists These steps ensure the proper installation and configuration of win32yank as the default clipboard tool, avoiding conflicts with xclip and/orxsel.\nNeovim Plugin Installation # 1. Open Neovim: # nvim 2. Allow the plugins to load. # Wait for the plugins to download. Once the plugins are installed, issue the command :Mason to view the progress of LSPs, linters, formatters, and debuggers installations.\nOnce everything has been installed, exit neovim and carry on with further configurations.\n3. Language Servers Customizations: # To add more language servers and debug adapters to the ones I\u0026rsquo;ve configured, check out the lsp server, linters, formatters and debug adapter configuration guides.\nYou can use Mason (opened with the command :Mason) to seamlessly install the configured servers. You can also use Mason to ensure certain servers, formatters, linters, and DAPs are installed. Check out the mason-lspconfig, mason-tool-installer and mason-nvim-dap configuration guides for more information on this.\n4. Language Parsers Customizations: # I\u0026rsquo;ve employed nvim-treesitter to customize language parsers. Explore their list of supported languages. To integrate a new language parser, just include it in the ensure_installed object within the nvim-treesitter configuration file (~/.config/nvim/lua/justice/plugins/nvim-treesitter.lua). Treesitter will handle the automatic installation of parsers specified in the ensure_installed section.\n5. Optional: Copilot auto-completion # To use copilot auto completion, you need to have a github copilot subscription. Authenticate to Copilot using :Copilot auth command. 6. For Java Developers: # Download and setup the java-debug extension. Install it on your neovim data folder ~/.local/share/nvim using the following commands:\ngit clone https://github.com/microsoft/java-debug.git ~/.local/share/nvim/java-debug cd ~/.local/share/nvim/java-debug ./mvnw clean install 7. For WSL users: # Uncomment the wsl clipboard block on ~/.config/nvim/lua/justice/core/options.lua if you are using WSL.\nvim.g.clipboard = { name = \u0026#34;win32yank-wsl\u0026#34;, copy = { [\u0026#34;+\u0026#34;] = \u0026#34;win32yank.exe -i --crlf\u0026#34;, [\u0026#34;*\u0026#34;] = \u0026#34;win32yank.exe -i --crlf\u0026#34;, }, paste = { [\u0026#34;+\u0026#34;] = \u0026#34;win32yank.exe -o --lf\u0026#34;, [\u0026#34;*\u0026#34;] = \u0026#34;win32yank.exe -o --lf\u0026#34;, }, cache_enabled = true, } Conclusions # That\u0026rsquo;s it! Your Neovim environment is now configured and ready for use. Customize further based on your preferences, and happy coding!\nNavigate to the next article in this series via the blue drop-down list at the end/beginning of this page for a detailed walkthrough of the keymaps configured in my Neovim setup. Recommendations # Congratulations on setting up your Neovim environment! If you\u0026rsquo;re looking to further enhance your terminal experience, I highly recommend checking out my tmux configuration post linked below. Tmux is a powerful terminal multiplexer that allows you to organize and manage multiple terminal sessions effortlessly.\nMy Tmux Configuration 20-01-2024\u0026middot;323 words\u0026middot;2 mins tmux neovim Happy coding!\n","date":"16-01-2024","permalink":"/posts/202401-my-neovim-configuration/","section":"Posts","summary":"Introduction # This article is a walkthrough on how to configure my neovim setup. My setup has been configured for working with Javascript, React, Python, Golang, and Java.\nScreenshots # Features # Plugins managed with lazy.","title":"My Neovim Configuration Setup Guide"},{"content":"","date":"09-03-2021","permalink":"/tags/cryptography/","section":"Tags","summary":"","title":"cryptography"},{"content":"","date":"09-03-2021","permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF"},{"content":"Introduction # We had an awesome CTF competition which was hosted by CyberSpaceKe that was held at Afralti Conference \u0026amp; Guest House located in Nairobi Kenya. There were a number of challenges to tackle within the 12 hours that the CTF was live, although am going to cover on how I solved the crypto challenge only, on this writeup.\nAdditional Resources # Firstly, we have to know how RSA works since the challenge was based on the RSA concept. A comprehensive description on how RSA works can be found here.\nSolution # For this challenge we are provided with a .zip file\non extracting the crypto.zip, we get three files, a README.txt, setup.py and crypto.py\nMy first step was to read the content of the readme file but it did not explain much. It only explained the padding method used and how to install the dependencies and how to run the script XD My next move was to run the setup.py python3 setup.py install that installs the packages needed for the challenge. let\u0026rsquo;s dive into the actual challenge ;p\nrunning the crypto.py, we are provided with public key, private key and the encrypted flag.. \u0026ldquo;easy one\u0026rdquo; XD we are provided, with the exponent, modulus and the secret(private key) which makes decrypting the flag even more easy\nin RSA; m(message) = ( c ^ d ) % n\nThis can be represented using the pow method in python as m = pow(c, d, n)\nwhere:\nC is the ciphertext in our case the ecrypted flag\nd is the private key;the secret value that was provided from the script\nn is the modulus\nSince we have all the values that are needed, I decided to write a python script to decrypt the flag and convert the values into text\nimport binascii modulus = 34164633714288263 privateKey = 13641456358166273 encryptedFlag = [25093029348589988, 4521027679642871, 24627307819255443, 9960547738404075, 11259248461081440, 22505742667320478, 9377760342138904, 23745739356821857, 25985317747963106, 21569289016296976, 33133895850821816, 6914007185378157, 27796025575756738, 15062199630481745] flag = [] for c in encryptedFlag: message = pow(c, privateKey, modulus) flag.append(message) flag = [hex(i) for i in flag] final = [str(i)[2:] for i in flag] for i in final: try: print(binascii.unhexlify(i).decode(), end=\u0026#34;\u0026#34;) except: pass on running the script, we get the flag;p ","date":"09-03-2021","permalink":"/posts/202103-cyberspaceke-the-cspke-cryptofree-vault-writeup/","section":"Posts","summary":"Introduction # We had an awesome CTF competition which was hosted by CyberSpaceKe that was held at Afralti Conference \u0026amp; Guest House located in Nairobi Kenya. There were a number of challenges to tackle within the 12 hours that the CTF was live, although am going to cover on how I solved the crypto challenge only, on this writeup.","title":"CyberSpaceKE the CSPKE CryptoFREE Vault Writeup"},{"content":"","date":"01-01-0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"01-01-0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]