[{"content":"","date":"17-02-2024","permalink":"/","section":"Justice Nyaga","summary":"","title":"Justice Nyaga"},{"content":"","date":"17-02-2024","permalink":"/series/my-neovim-configuration/","section":"Series","summary":"","title":"My Neovim Configuration"},{"content":"In this article, I\u0026rsquo;ll be sharing the keymaps I\u0026rsquo;ve configured within my Neovim setup to enhance simplicity and improve efficiency.\nBasic Keymaps # Keymap Mode Description \u0026lt;Space\u0026gt; N/A Leader key jk Insert Exit insert mode \u0026lt;leader\u0026gt;nh Normal Clear search highlights \u0026lt;leader\u0026gt;+ Normal Increment number under cursor \u0026lt;leader\u0026gt;- Normal Decrement number under cursor \u0026lt;leader\u0026gt;rw Normal Toggle Find \u0026amp; Replace \u0026lt;leader\u0026gt;rc Normal Toggle Find \u0026amp; Replace for word under cursor \u0026lt;C-z\u0026gt; Normal \u0026amp; Terminal Toggle FTerm terminal Window Management Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;sv Normal Split window vertically \u0026lt;leader\u0026gt;sh Normal Split window horizontally \u0026lt;leader\u0026gt;se Normal Make split windows equal width \u0026amp; height \u0026lt;leader\u0026gt;sm Normal Maximize/Minimize a split window \u0026lt;leader\u0026gt;sx Normal Close current slit window Tab Management Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;to Normal Open new tab \u0026lt;leader\u0026gt;tx Normal Close current tab \u0026lt;leader\u0026gt;tn Normal Go to next tab \u0026lt;leader\u0026gt;tp Normal Go to previous tab \u0026lt;leader\u0026gt;tf Normal Move current buffer to new tab Window Navigation Keymaps # Keymap Mode Description \u0026lt;C-h\u0026gt; Normal Move cursor to the window on the left \u0026lt;C-j\u0026gt; Normal Move cursor to the window below \u0026lt;C-k\u0026gt; Normal Move cursor to the window above \u0026lt;C-l\u0026gt; Normal Move cursor to the window on the right This works with my Tmux confnguration, so be sure to check it out as well. Link provided on the Recommendations section. File Explorer Keymaps # Explore the various keymaps of nvim-tree by opening the QUICKSTART HELP with g? while the cursor is on the explorer split. Close the help menu using q key. Keymap Mode Description \u0026lt;leader\u0026gt;ee Normal Toggle file explorer \u0026lt;leader\u0026gt;ef Normal Toggle file explorer on the current file \u0026lt;leader\u0026gt;ec Normal Collapse file explorer \u0026lt;leader\u0026gt;er Normal Refresh file explorer Navigation within Code # Keymap Mode Description ]f Normal Jump to next function call start ]m Normal Jump to next method/function definition start ]c Normal Jump to next class start ]i Normal Jump to next conditional start ]l Normal Jump to next loop start [f Normal Jump to previous function call start [m Normal Jump to previous method/function definition start [c Normal Jump to previous class start [i Normal Jump to previous conditional start [l Normal Jump to previous loop start Keymap Mode Description ]F Normal Jump to next function call end ]M Normal Jump to next method/function definition end ]C Normal Jump to next class end ]I Normal Jump to next conditional end ]L Normal Jump to next loop end [F Normal Jump to previous function call end [M Normal Jump to previous method/function definition end [C Normal Jump to previous class end [I Normal Jump to previous conditional end [L Normal Jump to previous loop end Keymap Mode Description ]s Normal Jump to next scope ]z Normal Jump to next fold Swap Text Objects in Code # Keymap Mode Description \u0026lt;leader\u0026gt;na Normal Swap parameter/argument with the next \u0026lt;leader\u0026gt;nm Normal Swap function with the next \u0026lt;leader\u0026gt;pa Normal Swap parameter/argument with the previous \u0026lt;leader\u0026gt;pm Normal Swap function with the previous Manipulate Text Objects in Code # In Normal mode, you can use the following key bindings prefixed with operations like d, c, or y to interact with text objects. Here are some examples:\ndaa: Delete the outer part of an argument. caa: Change the outer part of an argument. yaa: Yank the outer part of an argument. And so on.\nKeymap Mode Description a= Normal \u0026amp; Visual Select outer part of an assignment i= Normal \u0026amp; Visual Select inner part of an assignment l= Normal \u0026amp; Visual Select left hand side of an assignment r= Normal \u0026amp; Visual Select right hand side of an assignment aa Normal \u0026amp; Visual Select outer part of a parameter/argument ia Normal \u0026amp; Visual Select inner part of a parameter/argument ai Normal \u0026amp; Visual Select outer part of a condition ii Normal \u0026amp; Visual Select inner part of a condition al Normal \u0026amp; Visual Select outer part of a loop il Normal \u0026amp; Visual Select inner part of a loop af Normal \u0026amp; Visual Select outer part of a function call if Normal \u0026amp; Visual Select inner part of a function call am Normal \u0026amp; Visual Select outer part of a method/function definition im Normal \u0026amp; Visual Select inner part of a method/function definition ac Normal \u0026amp; Visual Select outer part of a class ic Normal \u0026amp; Visual Select inner part of a class Fuzzy Search Keybinds # Keymap Mode Description \u0026lt;leader\u0026gt;ff Normal Fuzzy find files in cwd \u0026lt;leader\u0026gt;fr Normal Fuzzy find recent files \u0026lt;leader\u0026gt;fs Normal Find strings in cwd \u0026lt;leader\u0026gt;fc Normal Find string under cursor in cwd Code Comments Keymaps # I use the default keymaps in Comment.nvim. To learn how to use them, check out their usage guide. Delimiter Pairs Keymaps # For swift manipulation of delimiter pairs, I rely on the default keymaps from nvim-surround. Explore their usage guide for insights into the diverse keymaps available. Code Completion # Keymap Mode Description \u0026lt;C-k\u0026gt; Insert Previous suggestion \u0026lt;C-j\u0026gt; Insert Next suggestion \u0026lt;C-b\u0026gt; Insert Scroll up \u0026lt;C-f\u0026gt; Insert Scroll down \u0026lt;C-Space\u0026gt; Insert Show completion suggestions \u0026lt;C-e\u0026gt; Insert Close completion window/menu \u0026lt;CR\u0026gt; Insert Select suggestion Language Server Keymaps # Keymap Mode Description gR Normal Show references and definition gD Normal Go to declaration gd Normal Show lsp definitions gi Normal Show lsp implementations gt Normal Show lsp type definitions \u0026lt;leader\u0026gt;ca Normal \u0026amp; Visual See available code actions \u0026lt;leader\u0026gt;rn Normal Smart rename \u0026lt;leader\u0026gt;D Normal Show diagnostics for file \u0026lt;leader\u0026gt;d Normal Show diagnostics for line \u0026lt;leader\u0026gt;[d Normal Jump to previous diagnostic in buffer \u0026lt;leader\u0026gt;]d Normal Jump to next diagnostic in buffer \u0026lt;leader\u0026gt;K Normal Show documentation for what is under cursor \u0026lt;leader\u0026gt;rs Normal Restart lsp Debugging Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;db Normal Toggle breaking point on line under cursor \u0026lt;leader\u0026gt;dC Normal Clear breakpoints \u0026lt;leader\u0026gt;ds Normal Start debugging session \u0026lt;leader\u0026gt;dc Normal Continue \u0026lt;leader\u0026gt;dn Normal Step over \u0026lt;leader\u0026gt;di Normal Step into \u0026lt;leader\u0026gt;do Normal Step out \u0026lt;leader\u0026gt;de Normal Close debugger and end debugging session \u0026lt;leader\u0026gt;dc Normal Continue Formatting Keymaps # Automatic formatting takes effect upon saving the current buffer, provided you have a formatter for the language in use. Keymap Mode Description \u0026lt;leader\u0026gt;mp Normal Format file \u0026lt;leader\u0026gt;mp Normal \u0026amp; Visual Format selected range Linting Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;l Normal Trigger linting for current file Git Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;gi Normal Git init \u0026lt;leader\u0026gt;ga Normal Stage current buffer \u0026lt;leader\u0026gt;gw Normal Save and stage current buffer in WT, checkout buffer in index \u0026lt;leader\u0026gt;gm Normal Rename and stage current buffer \u0026lt;leader\u0026gt;gs Normal Toggle open/close of status tab \u0026lt;leader\u0026gt;gd Normal Toggle open/close of diff tab \u0026lt;leader\u0026gt;gg Normal Open git graph Commits # Keymap Mode Description \u0026lt;leader\u0026gt;gcc Normal Populate git commit with message flag on command line \u0026lt;leader\u0026gt;gca Normal Amend the last commit \u0026lt;leader\u0026gt;gcm Normal populate git commit on command line Branches # Keymap Mode Description \u0026lt;leader\u0026gt;gbl Normal List all branches \u0026lt;leader\u0026gt;gbv Normal List all branches with their remote tracking branches \u0026lt;leader\u0026gt;gbo Normal Populate git branch on command line \u0026lt;leader\u0026gt;gba Normal Populate create branch and switch to it \u0026lt;leader\u0026gt;gbr Normal Populate rename branch \u0026lt;leader\u0026gt;gbd Normal Populate delete branch \u0026lt;leader\u0026gt;gbD Normal Populate force delete branch \u0026lt;leader\u0026gt;gco Normal Populate git checkout Stash # Keymap Mode Description \u0026lt;leader\u0026gt;gzz Normal Push stash (includes untracked files) from both WT and index \u0026lt;leader\u0026gt;gzw Normal Push stash (includes untracked files) from WT only \u0026lt;leader\u0026gt;gza Normal Apply top most stash \u0026lt;leader\u0026gt;gzA Normal Populate apply stash \u0026lt;leader\u0026gt;gzp Normal Pop top most stash \u0026lt;leader\u0026gt;gzP Normal Populate pop stash \u0026lt;leader\u0026gt;gzd Normal Drop top most stash \u0026lt;leader\u0026gt;gzD Normal Populate drop stash \u0026lt;leader\u0026gt;gzo Normal Populate git stash Merge # Keymap Mode Description \u0026lt;leader\u0026gt;gmo Normal Populate git merge \u0026lt;leader\u0026gt;gmt Normal Open merge tool consider using diffview for solving conflicts \u0026lt;leader\u0026gt;gmr Normal Continue merging \u0026lt;leader\u0026gt;gmx Normal Abort merging Rebase # Keymap Mode Description \u0026lt;leader\u0026gt;gri Normal Populate interactive rebase \u0026lt;leader\u0026gt;grn Normal Populate interactive rebase with count from HEAD \u0026lt;leader\u0026gt;grr Normal Continue with current rebase \u0026lt;leader\u0026gt;grx Normal Abort current rebase \u0026lt;leader\u0026gt;gre Normal Edit todo list of current rebase \u0026lt;leader\u0026gt;gro Normal Populate git rebase Cherry Pick # Keymap Mode Description \u0026lt;leader\u0026gt;gyi Normal Populate git cherry-pick \u0026lt;leader\u0026gt;gyr Normal Continue with cherry-pick \u0026lt;leader\u0026gt;gyx Normal Abort cherry-pick Reset # Keymap Mode Description \u0026lt;leader\u0026gt;grh Normal Reset the last commit \u0026lt;leader\u0026gt;gRr Normal Hard reset the last commit \u0026lt;leader\u0026gt;gri Normal Populate reset with count from HEAD \u0026lt;leader\u0026gt;gRi Normal Populate hard reset with count from HEAD \u0026lt;leader\u0026gt;grO Normal Populate git reset Remote # Keymap Mode Description \u0026lt;leader\u0026gt;gps Normal Git push \u0026lt;leader\u0026gt;gPs Normal Git force push \u0026lt;leader\u0026gt;gpl Normal Git pull \u0026lt;leader\u0026gt;gPL Normal Git force pull \u0026lt;leader\u0026gt;gpu Normal Populate git push set upstream \u0026lt;leader\u0026gt;gra Normal Populate add remote \u0026lt;leader\u0026gt;grd Normal Populate remove remote \u0026lt;leader\u0026gt;grl Normal List all remotes \u0026lt;leader\u0026gt;gor Normal Populate git remote Git diffview # Keymap Mode Description \u0026lt;leader\u0026gt;gd Normal Toggle open/close diffview tab \u0026lt;leader\u0026gt;gfh Normal Toggle open/close file history of current buffer tab \u0026lt;leader\u0026gt;gh Normal Toggle open/close all commits/files history tab \u0026lt;leader\u0026gt;gR Normal Toggle open/close diff of HEAD and main branch diffview File Panel # Keymap Mode Description j, \u0026lt;Down\u0026gt; Normal Move cursor to next file entry k, \u0026lt;Up\u0026gt; Normal Move cursor to next file entry o, \u0026lt;2-LeftMouse\u0026gt; Normal Select current entry - Normal Stage/unstage selected entry S Normal Stage all entries U Normal Unstage all entries X Normal Restore entry to state on left side R Normal Update stats and entries on file list \u0026lt;S-Up\u0026gt; Normal Scroll up \u0026lt;S-Down\u0026gt; Normal Scroll down \u0026lt;C-j\u0026gt; Normal Open diff for next entry \u0026lt;C-k\u0026gt; Normal Open diff for previous entry gf Normal Open file in a split window \u0026lt;CR\u0026gt; Normal Open file in a new tab i Normal Toggle between list/tree views f Normal Flatten empty subdirectories in tree listing style \u0026lt;leader\u0026gt;e Normal Bring focus to the file panel diffview View Panel # Keymap Mode Description \u0026lt;C-j\u0026gt; Normal Open diff for next file \u0026lt;C-k\u0026gt; Normal Open diff for previous file \u0026lt;CR\u0026gt; Normal Open file in a previous tab \u0026lt;C-w\u0026gt;\u0026lt;C-f\u0026gt; Normal Open file in a split window \u0026lt;C-w\u0026gt;gf Normal Open file in a new tab \u0026lt;leader\u0026gt;e Normal Bring focus to the file panel \u0026lt;leader\u0026gt;b Normal Toggle file panel diffview File History Panel # Keymap Mode Description g! Normal Open option panel \u0026lt;C-A-d\u0026gt; Normal Open entry under cursor in a diffview zR Normal Open all folds zM Normal Close all folds j, \u0026lt;Down\u0026gt; Normal Move cursor to next entry k, \u0026lt;Up\u0026gt; Normal Move cursor to previous entry o, \u0026lt;CR\u0026gt;, \u0026lt;2-LeftMouse\u0026gt; Normal Select entry \u0026lt;C-j\u0026gt; Normal Select next entry \u0026lt;C-k\u0026gt; Normal Select previous entry gf Normal Go to file \u0026lt;C-w\u0026gt;\u0026lt;C-f\u0026gt; Normal Open file in a split window \u0026lt;C-w\u0026gt;gf Normal Open file in a new tab \u0026lt;leader\u0026gt;e Normal Bring focus to the file panel \u0026lt;leader\u0026gt;b Normal Toggle file panel ","date":"17-02-2024","permalink":"/posts/202402-my-neovim-keymaps/","section":"Posts","summary":"In this article, I\u0026rsquo;ll be sharing the keymaps I\u0026rsquo;ve configured within my Neovim setup to enhance simplicity and improve efficiency.\nBasic Keymaps # Keymap Mode Description \u0026lt;Space\u0026gt; N/A Leader key jk Insert Exit insert mode \u0026lt;leader\u0026gt;nh Normal Clear search highlights \u0026lt;leader\u0026gt;+ Normal Increment number under cursor \u0026lt;leader\u0026gt;- Normal Decrement number under cursor \u0026lt;leader\u0026gt;rw Normal Toggle Find \u0026amp; Replace \u0026lt;leader\u0026gt;rc Normal Toggle Find \u0026amp; Replace for word under cursor \u0026lt;C-z\u0026gt; Normal \u0026amp; Terminal Toggle FTerm terminal Window Management Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;sv Normal Split window vertically \u0026lt;leader\u0026gt;sh Normal Split window horizontally \u0026lt;leader\u0026gt;se Normal Make split windows equal width \u0026amp; height \u0026lt;leader\u0026gt;sm Normal Maximize/Minimize a split window \u0026lt;leader\u0026gt;sx Normal Close current slit window Tab Management Keymaps # Keymap Mode Description \u0026lt;leader\u0026gt;to Normal Open new tab \u0026lt;leader\u0026gt;tx Normal Close current tab \u0026lt;leader\u0026gt;tn Normal Go to next tab \u0026lt;leader\u0026gt;tp Normal Go to previous tab \u0026lt;leader\u0026gt;tf Normal Move current buffer to new tab Window Navigation Keymaps # Keymap Mode Description \u0026lt;C-h\u0026gt; Normal Move cursor to the window on the left \u0026lt;C-j\u0026gt; Normal Move cursor to the window below \u0026lt;C-k\u0026gt; Normal Move cursor to the window above \u0026lt;C-l\u0026gt; Normal Move cursor to the window on the right This works with my Tmux confnguration, so be sure to check it out as well.","title":"My Neovim Keymaps"},{"content":"","date":"17-02-2024","permalink":"/tags/neovim/","section":"Tags","summary":"","title":"neovim"},{"content":"","date":"17-02-2024","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"17-02-2024","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"17-02-2024","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"11-02-2024","permalink":"/tags/arrays/","section":"Tags","summary":"","title":"arrays"},{"content":"Introduction # Arrays stand as one of the fundamental data structures, serving as a go-to choice for storing a sequence of items, be it strings, numbers, objects, or any other data type.\nThe effectiveness of arrays stems from their sequential storage in memory, as illustrated below:\nConsider an array of 5 integers, with the first item residing at memory address 100. Each subsequent item is placed in addresses like 104, 108, and so forth, given that integers in Java occupy 4 bytes each.\nThe efficiency of array indexing shines through with a constant runtime complexity of O(1). This simplicity arises from the direct calculation of memory addresses, free from loops or intricate logic. If your goal is to store a list of items and access them by index swiftly, arrays emerge as the optimal choice.\nLimitations of Arrays # Static Nature # Arrays, in Java and many other languages, have a fixed size. When you create an array, you have to decide how big it will be, and you can\u0026rsquo;t change it later. This becomes a problem when you don\u0026rsquo;t know exactly how many items you need. Guessing too high wastes memory because some spaces are never used. On the other hand, guessing too low means the array quickly gets filled up, and you have to resize it. Unfortunately, resizing has a cost, taking more time as the array gets bigger. This process is known as a runtime complexity of O(n).\nRemoval Operations # While removing the last item from an array is easy and quick (O(1) time), things get more complicated when removing an item at the beginning. In this case, all items to the right of the removed one need to shift to the left 1 position to fill the gap. The bigger the array, the more time it takes to do this. As a result, the worst-case runtime complexity for removing an item at the beginning is O(n).\nUnderstanding these details helps developers make smart choices about using arrays, thinking about both their benefits and drawbacks when creating efficient algorithms and data structures.\nWorking with Arrays in Java # When working with arrays in Java, you declare them using the following syntax:\nint[] variable_name = new int[3]; This statement declares an array that will store items of the integer type, with a size of 3, meaning it can only store 3 items. The variable_name is a variable that points to the memory address of the array.\nTo print the value of variable_name, it will display the array hash code along with the array type, i.e., the data type the array is storing.\npublic class Main{ public static void main(String[] args) { int[] variable_name = new int[3]; System.out.println(variable_name); } } Output: The [ Indicates its an array the I is the data type and the value after the @ is the array hash code.\nTo print the actual items in the array, you can use the Arrays class from the java.util package and the toString method to convert the array to a string.\nimport java.util.Arrays; public class Main{ public static void main(String[] args) { int[] variable_name = new int[3]; System.out.println(Arrays.toString(variable_name)); } } This will print [0, 0, 0] because when declaring arrays using this method, the array is instantiated with default values. For integers, the default value is 0.\nTo change the values of items in the array, you use their index as shown below:\nimport java.util.Arrays; public class Main{ public static void main(String[] args) { int[] variable_name = new int[3]; variable_name[0] = 10; variable_name[1] = 20; variable_name[2] = 30; System.out.println(Arrays.toString(variable_name)); } } The line variable_name[0] = 10; sets the value of the first item to 10, and so on.\nIf you know the items you are going to store in the array ahead of time, there is a shorter and cleaner way to initialize the array:\nimport java.util.Arrays; public class Main{ public static void main(String[] args) { int[] variable_name = { 10, 20, 30 }; System.out.println(Arrays.toString(variable_name)); System.out.println(variable_name.length); } } This method declares and initializes the array with the values provided in the braces, setting the size of the array to the number of items in the braces, which, in this case, is 3 and cannot be changed.\nIf you want to add another item to the array, you need to create a new array with a larger size, then copy the items from the old array and add the new item.\nimport java.util.Arrays; public class Main{ public static void main(String[] args) { int[] variable_name = { 10, 20, 30 }; int[] numbers = new int[4]; for (int i = 0; i \u0026lt; variable_name.length; i++) numbers[i] = variable_name[i]; numbers[3] = 40; System.out.println(Arrays.toString(variable_name)); } } This limitation of arrays in Java leads to the need for dynamic arrays or lists. If you want to work with lists that grow or shrink automatically, you would use linked lists.\nExercise # As you\u0026rsquo;ve learned, arrays in Java are static, meaning they have a fixed size that cannot be changed. In this section, we will create an Array class that behaves like a dynamic array. As we add new items, it will automatically grow, and as we remove items, it will automatically shrink.\npublic class Main { public static void main(String[] args) { Array numbers = new Array(3); // Create an instance of the Array class with an initial size of 3 // Adding items to the array numbers.insert(10); numbers.insert(20); numbers.insert(30); // Displaying the items in the array System.out.println(\u0026#34;Original array:\u0026#34;); numbers.print(); // Expected output: 10, 20, 30 on separate lines // Adding an item beyond the initial size (which was 3) numbers.insert(40); // Displaying the updated array after insertion System.out.println(); System.out.println(\u0026#34;Updated array - after insertion:\u0026#34;); numbers.print(); // Expected output: 10, 20, 30, 40 on separate lines // Removing an item at a specified index (0 in this case) numbers.removeAt(0); // This will remove the first item (10) // Displaying the updated array after removal System.out.println(); System.out.println(\u0026#34;Updated array - after removing index 0:\u0026#34;); numbers.print(); // Expected output: 20, 30, 40 on separate lines // Finding the index of an item (30 in this case) System.out.println(); System.out.println(\u0026#34;Index of 30 in the updated array:\u0026#34;); System.out.println(numbers.indexOf(30)); // Expected output: 1 System.out.println(numbers.indexOf(100)); // Expected output: -1 } } Creating the Dynamic Array Class # public class Array { private int[] items; // Array to store items private int count; // Number of items in the array // Constructor initializes the array based on the specified length public Array(int length) { items = new int[length]; } // Insert method adds an item to the array, dynamically resizing if needed public void insert(int item) { if (items.length == count) { // Resize the array by creating a new one with double the size int[] newItems = new int[count * 2]; // Copy existing items to the new array for (int i = 0; i \u0026lt; count; i++) newItems[i] = items[i]; items = newItems; // Update the array reference } items[count++] = item; // Add the new item at the end then increment the item count } // RemoveAt method removes an item at a given index, maintaining array integrity public void removeAt(int index) { if (index \u0026lt; 0 || index \u0026gt;= count) throw new IllegalArgumentException(\u0026#34;Invalid index\u0026#34;); // Shift items to the left to fill the gap for (int i = index; i \u0026lt; count - 1; i++) items[i] = items[i + 1]; count--; // Update the item count } // IndexOf method finds the index of a specified item public int indexOf(int item) { for (int i = 0; i \u0026lt; count; i++) if (items[i] == item) return i; // Return the index when the item is found return -1; // Return -1 if the item is not in the array } // Print method displays the items in the array public void print() { for (int i = 0; i \u0026lt; count; i++) System.out.println(items[i]); } } Testing the Dynamic Array # Now, let\u0026rsquo;s put the dynamic array to the test in the Main class.\npublic class Main { public static void main(String[] args) { Array numbers = new Array(3); // Adding items to the array numbers.insert(10); numbers.insert(20); numbers.insert(30); numbers.insert(40); // Displaying the items in the array after insertion System.out.println(\u0026#34;Updated array - after insertion:\u0026#34;); numbers.print(); // Removing an item at a specified index (0 in this case) numbers.removeAt(0); // Displaying the updated array after removal System.out.println(\u0026#34;Updated array - after removing index 0:\u0026#34;); numbers.print(); // Finding the index of an item (30 in this case) System.out.println(\u0026#34;Index of 30 in the updated array:\u0026#34;); System.out.println(numbers.indexOf(30)); System.out.println(numbers.indexOf(100)); } } In this implementation, the Array class dynamically adjusts its size, providing a flexible and efficient solution for managing arrays in Java.\nDynamic Arrays in Java # In our previous exercise, we acquired knowledge on constructing dynamic arrays, offering flexibility in managing data structures. Now, let\u0026rsquo;s delve into Java\u0026rsquo;s specific implementations of dynamic arrays: Vector and ArrayList. These implementations are vital components of the java.util package.\n1. Vector # The Vector class is a dynamic array that exhibits growth by 100% of its size when reaching capacity. This means that when the array is full, its size doubles to accommodate more elements efficiently.\n2. ArrayList # The ArrayList class, another dynamic array in Java, follows a growth strategy by 50% of its size when the array becomes full. This approach ensures a more conservative increase in size, balancing efficiency and memory utilization.\nExploring the ArrayList Class # Let\u0026rsquo;s take a quick tour of the ArrayList class with a code snippet:\nimport java.util.ArrayList; public class Main { public static void main(String[] args) { // Create an ArrayList of Integers ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(10); list.add(20); list.add(30); // Display the ArrayList System.out.println(list); // Output: [10, 20, 30] // Remove an element at index 0 list.remove(0); System.out.println(list); // Output: [20, 30] // Find the index of an element (e.g., 20) System.out.println(list.indexOf(20)); // Output: 0 // Add another 20 to the list list.add(20); System.out.println(list); // Output: [20, 30, 20] // Find the last occurrence of an element (e.g., 20) System.out.println(list.lastIndexOf(20)); // Output: 2 // Check if the list contains a specific element (e.g., 30) list.contains(30); // Returns a boolean value // Get the size of the ArrayList list.size(); // Convert the ArrayList to a regular array list.toArray(); } } This tour provides a glimpse into the versatility of the ArrayList class, showcasing its dynamic growth strategy, methods for manipulation, and additional utility functions. Understanding these dynamic array implementations is essential for effective data management in Java.\nConclusion # In conclusion, understanding arrays in Java is a foundational step in mastering data structures. Arrays provide a simple yet powerful way to organize and access data sequentially in memory, offering quick look-up times with a constant runtime complexity of O(1). However, it\u0026rsquo;s crucial to be aware of their limitations, particularly their static nature, requiring predefined sizes and potential inefficiencies when resizing.\nThis exploration of arrays serves as a foundation for a broader understanding of data structures and algorithms. The next destination in this series is the intriguing world of Linked Lists, where we\u0026rsquo;ll delve into new possibilities for data organization and manipulation.\nAs you progress through this series, mastering fundamental data structures like arrays will empower you to create efficient algorithms and build strong, reliable applications.\nReferences # Mosh Hamedani. Ultimate Data Structures \u0026amp; Algorithms: Part 1 JavaTpoint - JavaTpoint\u0026rsquo;s comprehensive tutorials on \u0026ldquo;Array in Data Structure\u0026rdquo; in Java. ","date":"11-02-2024","permalink":"/posts/202402-arrays/","section":"Posts","summary":"Introduction # Arrays stand as one of the fundamental data structures, serving as a go-to choice for storing a sequence of items, be it strings, numbers, objects, or any other data type.","title":"Arrays: The Fundamental Data Structure"},{"content":"","date":"11-02-2024","permalink":"/series/data-structures-and-algorithms/","section":"Series","summary":"","title":"Data Structures and Algorithms"},{"content":"","date":"11-02-2024","permalink":"/tags/data-structures-and-algorithms/","section":"Tags","summary":"","title":"data-structures-and-algorithms"},{"content":"Introduction # Big O notation is a mathematical tool that helps describe the limiting behavior of a function as its input approaches infinity. It is commonly used in computer science to analyze and compare the efficiency of algorithms. In this article, we will explore the basics of Big O notation and its application in understanding algorithmic performance.\nUnderstanding Big O Notation # Big O notation, denoted as O(f(n)), provides an upper bound on the growth rate of a function concerning the size of its input. In simpler terms, it describes how the runtime or space requirements of an algorithm scale with the size of the input.\nO(1) - Constant Time Complexity # Consider the following Java snippet:\npublic class Main { public void log(int[] numbers) { // O(1) System.out.println(numbers[0]); } } This snippet has a constant time complexity O(1) because the execution time remains constant regardless of the size of the input array. Adding more print statements or operations within the method does not change its constant time nature.\npublic class Main { public void log(int[] numbers) { // O(2) System.out.println(numbers[0]); System.out.println(numbers[0]); } } We have two operations, both running in constant time, so the runtime complexity of the method is still O(1). In this method, the size of the input does not matter; the method will always execute in constant time.\nO(n) - Linear Time Complexity # Linear time complexity, denoted as O(n), describes algorithms whose runtime grows proportionally with the size of the input. Let\u0026rsquo;s explore some examples to better understand this concept.\nBasic Linear Operation # Consider the following Java code:\npublic class Main { public void log(int[] numbers) { // O(n) for (int i = 0; i \u0026lt; numbers.length; i++) System.out.println(numbers[i]); } } In this example, the method iterates through each element in the numbers array, and the time complexity is linear O(n). The larger the input array, the longer the runtime.\nConstant-Time Operations in Linear Context # Now, let\u0026rsquo;s examine a scenario where we add constant-time operations before and after the loop:\npublic class Main { public void log(int[] numbers) { // O(1 + n + 1) -\u0026gt; O(2+n) -\u0026gt; O(n) System.out.println(); // O(1) for (int i = 0; i \u0026lt; numbers.length; i++) // O(n) System.out.println(numbers[i]); System.out.println(); // O(1) } } Despite the added constant-time operations, the overall time complexity remains O(n). This illustrates the principle that constants are typically dropped in Big O analysis.\nMultiple Linear Loops # Let\u0026rsquo;s consider a scenario with two loops:\npublic class Main { public void log(int[] numbers) { // O(n + n) -\u0026gt; O(2n) -\u0026gt; O(n) for (int number : numbers) // O(n) System.out.println(number); for (int number : numbers) // O(n) System.out.println(number); } } The presence of two linear operations still results in linear time complexity O(n), as constants are dropped in Big O notation.\nLinear Time Complexity with Multiple Parameters # Adding more parameters to a method does not change its fundamental linear time complexity:\npublic class Main { public void log(int[] numbers, String[] names) { // O(n + m) -\u0026gt; O(n) for (int number : numbers) // O(n) System.out.println(number); for (String name : names) // O(m) System.out.println(name); } } In this case, the overall runtime complexity is O(n), as we focus on the parameter that has linear growth.\nO(n2) - Quadratic Time Complexity # Quadratic time complexity, denoted as O(n²), characterizes algorithms that exhibit a growth rate proportional to the square of the input size. This often occurs with nested loops, where each iteration contributes to the overall growth. Let\u0026rsquo;s delve into examples to gain a clearer understanding.\nNested Loop Scenario # Consider the following Java code:\npublic class Main { public void log(int[] numbers) { // O(n * n) -\u0026gt; O(n^2) for (int first : numbers) // O(n) for (int second : numbers) // O(n) System.out.println(first + \u0026#34;, \u0026#34; + second); } } In this example, the outer loop iterates through each element in the numbers array, and for each iteration of the outer loop, the inner loop also traverses the entire array. The result is a quadratic time complexity of O(n²).\nAlgorithms that run in O(n²) run slower than algorithms that run in O(n)\nAdditional Operations in Quadratic Context # Let\u0026rsquo;s examine a scenario where we have additional operations before or after the nested loop:\npublic class Main { public void log(int[] numbers) { // O(n + n^2) -\u0026gt; O(n^2) for (int number : numbers) // O(n) System.out.println(number); for (int first : numbers) // O(n) for (int second : numbers) // O(n) System.out.println(first + \u0026#34;, \u0026#34; + second); } } In this example, the first loop has a time complexity of O(n) as it iterates through each element in the numbers array. The nested loop, however, has a quadratic time complexity of O(n²), as it iterates through each combination of elements in the array. When we express the overall time complexity as O(n + n²), we recognize that the dominant factor is the quadratic term n².\nThe rationale for dropping the linear term n is rooted in the principle of Big O notation, where we focus on the dominant term that contributes the most to the growth rate. In this context, as the size of the input n becomes larger, the impact of the quadratic term n² becomes significantly more substantial, overshadowing the linear term. Therefore, for the purpose of understanding how the cost of the algorithm increases relative to its input size, we simplify the expression to O(n²).\nImpact of Nested Loops on Growth Rate # What if we had nested loops within the original nested loop:\npublic class Main { public void log(int[] numbers) { // O(n * n * n) -\u0026gt; O(n^3) for (int first : numbers) // O(n) for (int second : numbers) // O(n) for (int third : numbers) // O(n) System.out.println(first + \u0026#34;, \u0026#34; + second + \u0026#34;, \u0026#34; + third); } } In this case, the time complexity becomes cubic O(n³), showcasing how the growth rate accelerates with additional nested loops.\nAlgorithms that run in O(n³) are far slower than those that run in O(n²) and O(n). The exponential increase in computational cost makes algorithms with cubic time complexity less scalable and less efficient compared to their quadratic and linear counterparts. This underscores the importance of considering the time complexity when designing algorithms for optimal performance.\nO(log n) - Logarithmic Time Complexity # Another growth rate we are going to talk about is the logarithmic growth, denoted as O(log n). Here is a logarithmic curve for better visualization:\nCompare it with a linear curve:\nThe linear curve grows at the same rate, while the logarithmic curve slows down at some point. An algorithm that runs in logarithmic time is more efficient and more scalable than an algorithm that runs in linear or quadratic time.\nExample # Let\u0026rsquo;s consider an algorithm with logarithmic time complexity:\nAssuming we have an array of sorted numbers from 1 to 10 and we want to find the number 10. We can implement the Binary Search algorithm, which runs in logarithmic time.\npublic class Main { public int binarySearch(int[] sortedArray, int target) { int low = 0; int high = sortedArray.length - 1; while (low \u0026lt;= high) { int mid = (low + high) / 2; if (sortedArray[mid] == target) { return mid; // Target found } else if (sortedArray[mid] \u0026lt; target) { low = mid + 1; // Search in the right half } else { high = mid - 1; // Search in the left half } } return -1; // Target not found } } In this example, the Binary Search algorithm efficiently narrows down the search space in each iteration. The key advantage comes from the fact that it operates on a sorted array. By continually halving the search space, it minimizes the number of comparisons needed to find the target element. In contrast, a linear search would require iterating through all items in the array, and in the worst case scenario, the target item could be the last element. This linear approach becomes increasingly inefficient as the size of the dataset grows.\nThe logarithmic time complexity O(log n) of the Binary Search algorithm makes it significantly more efficient, especially when dealing with large datasets, as it avoids unnecessary iterations and quickly converges to the target element.\nO(2n) - Exponential Time Complexity # Another type of growth is exponential growth, denoted as O(2ⁿ).\nThe exponential growth is the opposite of logarithmic growth, where the curve grows faster and faster.\nThe logarithmic curve slows down as the input size grows, but the exponential curve grows faster and faster. An algorithm that runs in exponential time is not scalable and would become very slow very soon.\nExample # Let\u0026rsquo;s explore an algorithm with exponential time complexity:\npublic class Main { public int fibonacci(int n) { if (n \u0026lt;= 1) { return n; } else { return fibonacci(n - 1) + fibonacci(n - 2); } } } In this example, the Fibonacci algorithm, which calculates Fibonacci numbers recursively, exhibits exponential time complexity O(2ⁿ). As the input value increases, the number of recursive calls grows exponentially, leading to a rapid increase in computational cost.\nExponential time complexity is not scalable for large inputs, making algorithms with this complexity impractical for certain applications.\nSpace Complexity # We\u0026rsquo;ve seen how Big O Notation helps describe the runtime complexity of algorithms. Ideally, we want our algorithms to be fast, scalable, and use minimal memory. However, this ideal is rarely achieved. Most often, we must make trade-offs between saving time and saving space.\nSometimes we have extra space, allowing us to optimize algorithms for speed and scalability. Other times, especially when building apps for small devices, space is limited, and we prioritize optimizing for space over scalability.\nSo, we need a way to talk about how much space an algorithm requires, and that\u0026rsquo;s where we use the Big O Notation again.\nO(x) # public class Main { public void greet(String[] names) { // O(1) space for (int i = 0; i \u0026lt; names.length; i++) System.out.println(\u0026#34;Hi\u0026#34; + names[i]); } } In this greet method, the loop variable i is independent of the size of the input. Whether the array has 10 or a million items, the method will only allocate a constant amount of memory for the loop variable, representing O(1) space complexity.\nWhat if we declare a copy string array and initialize it as shown below:\npublic class Main { public void greet(String[] names) { // O(n) space String[] copy = new String[names.length]; for (int i = 0; i \u0026lt; names.length; i++) copy[i] = names[i]; } } Conclusion # The growth rates we\u0026rsquo;ve explored are common in algorithmic analysis. While they represent just a subset of possibilities, they capture scenarios frequently encountered.\nIn this series, we\u0026rsquo;ll mainly focus on runtime complexity, tackling its intricate aspects. Nevertheless, it\u0026rsquo;s crucial to also consider space complexity in your algorithms, especially in situations where memory is limited. As you navigate algorithmic challenges, think creatively about preserving memory.\nReferences # Mosh Hamedani. Ultimate Data Structures \u0026amp; Algorithms: Part 1 Wikipedia - Big O Notation ","date":"10-02-2024","permalink":"/posts/202402-big-o-notation/","section":"Posts","summary":"Introduction # Big O notation is a mathematical tool that helps describe the limiting behavior of a function as its input approaches infinity. It is commonly used in computer science to analyze and compare the efficiency of algorithms.","title":"Big O Notation: Understanding Algorithmic Efficiency"},{"content":"","date":"10-02-2024","permalink":"/tags/big-o-notation/","section":"Tags","summary":"","title":"big-o-notation"},{"content":"Introduction # Developing Java code in Neovim can be a seamless experience with the right Language Server Protocol (LSP) setup. In this blog post, we will explore how to enhance your Neovim environment for Java development by configuring nvim-jdtls. This plugin, available at nvim-jdtls, offers a comprehensive set of features tailored for Java, addressing challenges such as navigating to the definition of methods and classes outside your project.\nBefore we proceed, ensure you\u0026rsquo;ve checked out my Neovim configuration post, which complements this setup:\nMy Neovim Configuration Setup Guide 16-01-2024\u0026middot;953 words\u0026middot;5 mins lua neovim Prerequisites # Neovim version \u0026gt;= 0.6.0\nVerify your Neovim version using:\nnvim --version Java runtime environment 17 and above\nInstall the desired Java version, ensuring it is 17 or above. For example, to install OpenJDK version 21:\nsudo apt install openjdk-21-jdk Set the JAVA_HOME environment variable to point to the JDK or JRE directory. Identify the correct path using:\nsudo update-alternatives --config java Set JAVA_HOME in your .bashrc or .zshrc:\nexport JAVA_HOME=/path/to/openjdk-21 For example:\nexport JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64 eclipse.jdt.ls\nDownload and extract a snapshot build from http://download.eclipse.org/jdtls/snapshots/:\nwget https://download.eclipse.org/jdtls/snapshots/jdt-language-server-1.31.0-202312211634.tar.gz \u0026amp;\u0026amp; sudo tar -C /usr/local -xzf jdt-language-server-1.31.0-202312211634.tar.gz java-debug To debug java programs, load the java-debug extension. Install it on your neovim data folder ~/.local/share/nvim using the following commands\ngit clone https://github.com/microsoft/java-debug.git ~/.local/share/nvim/java-debug cd ~/.local/share/nvim/java-debug ./mvnw clean install Installing plugins # 1. nvim-jdtls # Install the plugin using your preferred plugin manager. If using Lazy, add the following line to your init.lua file and install with :Lazy:\n\u0026#34;mfussenegger/nvim-jdtls\u0026#34;, -- java lsp 2. nvim-dap # Install nvim-dap using your preferred plugin manager. Check out my nvim-dap configuration which provides a user-friendly UI as well as key mappings for debugging.\n3. jdtls LSP # Install jdtls lsp using Mason by initiating mason with :Mason and proceeding with the installation. Check out my Mason configuration if you haven\u0026rsquo;t setup Mason. Mason is just a plugin for managing LSPs, linters, formatters, and DAPs.\nConfiguration # 1. Avoid confict between nvim-lspconfig and nvim-jdtls # Skip this step if you are not using nvim-lspconfig.\nTo avoid conficts, ensure you do not run nvim-lspconfig and nvim-jdtls simultaneously. Add the following setup_handler configuration to your nvim-lspconfig (in my case it\u0026rsquo;s ~/.config/nvim/lua/justice/plugins/lsp/lspconfig.lua):\n-- empty function to ignore jdtls local noop = function() end require(\u0026#34;mason-lspconfig\u0026#34;).setup_handlers({ function(server_name) lspconfig[server_name].setup({ on_attach = on_attach, capabilities = capabilities, }) end, [\u0026#34;jdtls\u0026#34;] = noop, }) 2. jdtls configuration # Create a ~/.config/nvim/ftplugin/java.lua file with the following code for jdtls configuration:\nlocal jdtls_bin = vim.fn.stdpath(\u0026#34;data\u0026#34;) .. \u0026#34;/mason/bin/jdtls\u0026#34; local keymap = vim.keymap local opts = { noremap = true, silent = true } local lsp_attach = function(client, bufnr) require(\u0026#34;jdtls.dap\u0026#34;).setup_dap_main_class_configs() -- Discover main classes for debugging opts.buffer = bufnr -- set keybinds. Copied my lspconfig keybinds here end local config = { cmd = { jdtls_bin }, root_dir = vim.fs.dirname(vim.fs.find({ \u0026#34;gradlew\u0026#34;, \u0026#34;.git\u0026#34;, \u0026#34;mvnw\u0026#34; }, { upward = true })[1]), on_attach = lsp_attach, init_options = { bundles = { vim.fn.glob(vim.fn.stdpath(\u0026#34;data\u0026#34;) .. \u0026#34;/java-debug/com.microsoft.java.debug.plugin/target/com.microsoft.java.debug.plugin-*.jar\u0026#34;, 1), }, }, } require(\u0026#34;jdtls\u0026#34;).start_or_attach(config) 3. nvim-dap configuration # Given that you have already installed nvim-dap, nvim-jdtls provides integration with nvim-dap, so you don\u0026rsquo;t need to configure Java debug adapters; nvim-jdtls adds that for you automatically. The only thing you\u0026rsquo;ll need to do is add a java configuration for debugging. Check out their wiki for more details. Add the following configuration to your nvim-dap plugin configuration file\nrequire(\u0026#34;dap\u0026#34;).configurations = { java = { { type = \u0026#34;java\u0026#34;, name = \u0026#34;Debug\u0026#34;, request = \u0026#34;launch\u0026#34;, program = \u0026#34;${file}\u0026#34;, }, }, -- configurations for other languages } My configuration files # Explore my configuration files by visiting lspconfig.lua, java.lua and dap.lua.\nConclusion # Kudos on completing the setup! Your Neovim environment is now finely tuned for Java development with the configured Java LSP. Wishing you smooth coding sessions ahead - Happy coding!\n","date":"05-02-2024","permalink":"/posts/202402-configuring-java-lsp-for-neovim-with-nvim-jdtls/","section":"Posts","summary":"Introduction # Developing Java code in Neovim can be a seamless experience with the right Language Server Protocol (LSP) setup. In this blog post, we will explore how to enhance your Neovim environment for Java development by configuring nvim-jdtls.","title":"Configuring Java LSP, and Debugger for Neovim with nvim-jdtls"},{"content":"","date":"05-02-2024","permalink":"/tags/nvim-jdtls/","section":"Tags","summary":"","title":"nvim-jdtls"},{"content":"","date":"05-02-2024","permalink":"/tags/nvim-lspconfig/","section":"Tags","summary":"","title":"nvim-lspconfig"},{"content":"I\u0026rsquo;m a fullstack software developer based in Kenya. I\u0026rsquo;m proficient in Python, Django, Javascript, Node.js, React, React Native and Golang.\nDive into my blog for concise insights and hands-on experiences, where we\u0026rsquo;ll unravel the intricacies of software engineering together. Let\u0026rsquo;s embark on this coding journey!\nFeel free to reach out.\n","date":"01-02-2024","permalink":"/about/","section":"Justice Nyaga","summary":"I\u0026rsquo;m a fullstack software developer based in Kenya. I\u0026rsquo;m proficient in Python, Django, Javascript, Node.js, React, React Native and Golang.\nDive into my blog for concise insights and hands-on experiences, where we\u0026rsquo;ll unravel the intricacies of software engineering together.","title":"About Me"},{"content":"Step into the realm of my digital playground, a space where curiosity meets code and innovation takes flight. Within these project walls, each endeavor is a crafted narrative, a testament to my commitment to perpetual learning and creative exploration.\nLogo Title Description Link Proshop A fake shopping app built on React. The app utilizes proshop_api (Django REST API) sitegithub Proshop-Api An e-commerce REST API crafted with Django and Django Rest Framework, incorporating diverse shopping app features. sitegithub Bridge School A student management system web application github DoneWithIt A faux native app marketplace designed for selling items you no longer need. github ","date":"31-01-2024","permalink":"/projects/","section":"Justice Nyaga","summary":"Step into the realm of my digital playground, a space where curiosity meets code and innovation takes flight. Within these project walls, each endeavor is a crafted narrative, a testament to my commitment to perpetual learning and creative exploration.","title":"Projects"},{"content":"Introduction # Welcome to this comprehensive guide on installing and configuring Ubuntu Desktop environment on Windows Subsystem for Linux 2 (WSL2). Enhance your development environment and streamline your coding experience with this step-by-step walkthrough.\nThis post assumes that you have already installed Ubuntu within WSL2. If not, please do install it before proceeding.\nStep 1: Install Ubuntu Desktop and Mesa-utils # Begin by installing the Ubuntu Desktop and mesa-utils packages:\nsudo apt update sudo apt install ubuntu-desktop mesa-utils Troubleshooting for \u0026ldquo;Transport endpoint is not connected\u0026rdquo; error # If you encounter the error \u0026ldquo;Transport endpoint is not connected\u0026rdquo; during the setup, perform the following troubleshooting steps:\nPress Ctrl + C to skip packages with the error. Run the following commands: sudo mv /etc/acpi/events /etc/acpi/events.bak sudo ln -s /dev/null /etc/systemd/system/acpid.service sudo ln -s /dev/null /etc/systemd/system/acpid.path Run the following command to reconfigure the unpacked packages that were skipped on the previous step.\nsudo dpkg --configure -a Step 2: Set Up Environment Variables # Configure environment variables for persistent settings. It\u0026rsquo;s recommended to add these to your .bashrc or .zshrc:\nexport DISPLAY=\u0026#34;$(grep nameserver /etc/resolv.conf | sed \u0026#39;s/nameserver //\u0026#39;):0\u0026#34; export LIBGL_ALWAYS_INDIRECT=0 Step 3: Install VcXsrv on Windows # On the Windows side, install VcXsrv. After installation, choose the following setup options:\nMultiple windows\nDisplay number: 0\nStart no client\nCheck everything on Extra settings, that is, clipboard, primary selection, Native opengl, Disable access control\nYou can save the configuration for future use\nClick finish to start the server\nStep 4: Verify Installation with xeyes # Ensure VcXsrv is running and test the setup by opening xeyes app or any other installed desktop app such as firefox on your WSL terminal:\nxeyes Conclusion # The successful opening of the xeyes app indicates that you have seamlessly set up the Ubuntu Desktop environment on WSL2. Happy coding!\n","date":"31-01-2024","permalink":"/posts/202401-setting-up-ubuntu-desktop-environment-on-wsl2/","section":"Posts","summary":"A comprehensive guide to installing and configuring the Ubuntu Desktop environment on Windows Subsystem for Linux 2 (WSL2). Enhance your development environment and streamline your coding experience with this step-by-step walkthrough.","title":"Setting up Ubuntu Desktop Environment on WSL2"},{"content":"","date":"31-01-2024","permalink":"/tags/ubuntu/","section":"Tags","summary":"","title":"ubuntu"},{"content":"","date":"31-01-2024","permalink":"/tags/ubuntu-desktop/","section":"Tags","summary":"","title":"ubuntu-desktop"},{"content":"","date":"31-01-2024","permalink":"/tags/vcxsrv/","section":"Tags","summary":"","title":"vcxsrv"},{"content":"","date":"31-01-2024","permalink":"/tags/wsl2/","section":"Tags","summary":"","title":"wsl2"},{"content":"Introduction # Welcome to the world of Tmux, where terminal multitasking becomes a breeze. In this guide, we\u0026rsquo;ll walk through setting up and enhancing your Tmux experience with a customized configuration.\nDesigned for efficient integration with Neovim, this carefully crafted configuration aims to streamline your terminal workflow. It provides a seamless and productive environment for both Tmux and Neovim enthusiasts. Whether you\u0026rsquo;re a seasoned user or just diving into the world of terminal customization, this guide will help you unlock the full potential of Tmux in conjunction with Neovim. Let\u0026rsquo;s dive in!\nConfiguration Setup Step # Follow these steps to set up and enhance your Tmux experience:\nInstall Tmux:\nIf Tmux is not already installed on your system, you can install it using your package manager. For example, on Debian-based systems, run:\nsudo apt-get install tmux Verify the installation by checking the Tmux version:\ntmux -V Retrieve the Configuration File:\nDownload the Tmux configuration file and seamlessly integrate it into your home directory using the following command:\nwget https://raw.githubusercontent.com/justicenyaga/my_nvim_config/main/.tmux.conf -O ~/.tmux.conf Install Tmux Plugin Manager (tpm):\nClone the Tmux Plugin Manager repository to your local machine:\ngit clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm Create a Tmux session:\nStart a new Tmux session with a specific name (replace SessionName with your desired name):\ntmux new -s SessionName This should create a session and attach you to the created session.\nReload the Tmux configuration file:\nPress your Tmux prefix key (the configuration file uses Ctrl + N) followed by r to reload the configuration file:\n\u0026lt;C-n\u0026gt;r On the configuration file, replace C-n with a prefered key bind to override the default prefix key bind, on the following lines:\nset -g prefix C-n bind-key C-n send-prefix Install Tmux plugins:\nWhile inside a Tmux session, install plugins by pressing your Tmux prefix key followed by I (uppercase):\n\u0026lt;C-n\u0026gt;I Again, replace \u0026lt;C-n\u0026gt; with your configured prefix key bind. That\u0026rsquo;s it! Your Tmux environment is now configured with the specified settings and plugins. Customize further based on your preferences.\nUsage # Keybinds Explanation # Prefix Key: C-n\nThe prefix key is set to C-n for easier accessibility and to avoid conflicts with the default C-b. It\u0026rsquo;s a comfortable and ergonomic choice. Vertical Split: prefix + |\nThe keybind for vertical split is set to prefix + | for better visualization. The vertical bar (|) visually represents a vertical split, making it intuitive and memorable. Horizontal Split: prefix + -\nHorizontal split is initiated with prefix + -, providing a straightforward and balanced key combination for creating horizontal panes. Reload Configuration: prefix + r\nReloading the configuration is done with prefix + r, making it quick and easy to apply any changes made to the configuration file. Resize Panes: prefix + j/k/l/h\nResizing panes is streamlined with prefix + j/k/l/h for downward, upward, right, and left respectively. The mnemonic association with arrow keys makes it intuitive. Maximize Pane: prefix + m\nThe keybind prefix + m maximizes the active pane, providing a convenient way to focus on one task at a time. Enable Mouse Mode: prefix + M\nMouse mode is toggled with prefix + M, allowing for easy resizing and scrolling using the mouse. Copy Mode and Selection # Enter Copy Mode: prefix + [\nCopy mode is entered with prefix + [, initiating vi-style selection for efficient copying of text. Start Selection: v\nText selection starts with the v key in copy mode, following the vi-style conventions. Copy Selection: y\nThe selected text is copied using the y key in copy mode, mirroring vi-style copy operations. No Exit on Mouse Drag:\nDragging with the mouse in copy mode (MouseDragEnd1Pane) won\u0026rsquo;t exit copy mode, providing a seamless experience. Neovim Integration # No Delay for Exiting Insert Mode:\nThe delay for exiting insert mode with ESC in Neovim is removed (escape-time 10), ensuring a smooth transition. Tmux Plugins # Tmux Plugin Manager (tpm):\nThe Tmux Plugin Manager is initialized at the bottom of the configuration, allowing easy management of plugins. List of Plugins:\nvim-tmux-navigator: Navigate seamlessly between Vim and Tmux panes. tmux-themepack: A collection of themes for Tmux. tmux-resurrect: Persist Tmux sessions after computer restart. tmux-continuum: Automatically save sessions every 15 minutes. Theme: Powerline Cyan\nThe chosen theme from tmux-themepack is powerline/default/cyan for a visually appealing and distinctive look. Remember to customize these keybinds further based on your preferences and workflow!\n","date":"20-01-2024","permalink":"/posts/202401-my-tmux-configuration/","section":"Posts","summary":"Introduction # Welcome to the world of Tmux, where terminal multitasking becomes a breeze. In this guide, we\u0026rsquo;ll walk through setting up and enhancing your Tmux experience with a customized configuration.","title":"My Tmux Configuration: Elevating Your Terminal Experience"},{"content":"","date":"20-01-2024","permalink":"/tags/tmux/","section":"Tags","summary":"","title":"tmux"},{"content":"","date":"20-01-2024","permalink":"/tags/tmux-continuum/","section":"Tags","summary":"","title":"tmux-continuum"},{"content":"","date":"20-01-2024","permalink":"/tags/tmux-resurrect/","section":"Tags","summary":"","title":"tmux-resurrect"},{"content":"","date":"20-01-2024","permalink":"/tags/tmux-themepack/","section":"Tags","summary":"","title":"tmux-themepack"},{"content":"","date":"20-01-2024","permalink":"/tags/tpm/","section":"Tags","summary":"","title":"tpm"},{"content":"","date":"20-01-2024","permalink":"/tags/vim-tmux-navigator/","section":"Tags","summary":"","title":"vim-tmux-navigator"},{"content":"","date":"16-01-2024","permalink":"/tags/lua/","section":"Tags","summary":"","title":"lua"},{"content":"Introduction # Welcome to my Neovim configuration repository, where I\u0026rsquo;ve curated a powerful setup tailored for developers working with Node.js, React, Python, Golang, and Java.\nScreenshots # Features # Plugins managed with lazy.nvim Syntax highlighting with treesitter Code snippets and code auto-completion via nvim-cmp LSPs installed with Mason and configured using lspconfig Code formatting with conform Debuggers installed and configured with nvim-dap Terminal integration with fterm Fuzzy searching with telescope Git decorations to reflect changes in files using gitsigns.nvim Git integration via fugitive Git branch/commit/diff viewing via diffview Beautiful and powerful git graph via vim-flog friendly-snippets and VS Code ES7 snippets Faster code commenting with Comment.nvim Quicky add/delete/change delimiter pairs with nvim-surround Fold management with nvim-ufo Beautiful status bar via lualine nightfly colorscheme nvim-tree file explorer with nvim-web-devicons for the icons Beautiful UI via dressing.nvim Animated GUI notifications via nvim-notify Tabs and Splits navigation via vim-tmux-navigator Prerequisites # Before diving into the configuration, ensure you have the following prerequisites installed:\n1. Ensure you have Neovim v0.9 and Above: # Ensure that you have Neovim version 0.9 or above installed. Check your Neovim version using:\nnvim --version 2. Install python3.10-venv: # Install the python3.10-venv package using the following command:\nsudo apt install python3.10-venv 3. Install Go (Golang): # Certain plugins in my configuration rely on Go. Ensure a seamless experience by installing Go using the official installation guide.\nAfter installation, set up the required environment variables in your shell configuration file (e.g., .bashrc or .zshrc):\nexport GOPATH=~/go export GOROOT=/usr/local/go export PATH=$PATH:/usr/local/go/bin export PATH=$PATH:~/go/bin 4. Node Packages: # Install neovim and tree-sitter node packages by running the following command:\nnpm i -g neovim tree-sitter 5. pynvim Package: # Install the pynvim package using pip:\npython3 -m pip install -U pynvim Ensure that the python command points to python3 by adding the following alias on your .bashrc or .zshrc:\nalias python=python3 6. Telescope requirements: # For telescope to work without any issues, you need to have both ripgrep and fd packages. Install them using:\nsudo apt install ripgrep fd-find 7. Optional: Go Language Server (gopls): # For Go developers, consider installing the Go Language Server (gopls) to enhance your Go programming experience. Run the following command:\ngo install golang.org/x/tools/gopls@latest 8. Optional: Java # For Java developer, follow the following steps:\nEnsure you are running JRE 17 and above java --version Ensure JAVA_HOME environment variable points to the JDK directory. Identify the correct path using: sudo update-alternatives --config java Set JAVA_HOME in your .bashrc or .zshrc: export JAVA_HOME=/path/to/openjdk For example: export JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64 Download and extract a snapshot build from http://download.eclipse.org/jdtls/snapshots/ using: wget https://download.eclipse.org/jdtls/snapshots/jdt-language-server-1.31.0-202312211634.tar.gz \u0026amp;\u0026amp; sudo tar -C /usr/local -xzf jdt-language-server-1.31.0-202312211634.tar.gz 9. Clone Configuration Repository: # Clone my Neovim configuration repository to ~/.config/nvim:\ngit clone https://github.com/justicenyaga/my_nvim_config.git ~/.config/nvim 10. Optional: win32yank for WSL # For WSL users, install win32yank for clipboard interaction between Windows and WSL by following these steps:\nDownload win32yank binary:\nVisit https://github.com/equalsraf/win32yank/releases to download the win32yank binary. Copy it to /usr/local/bin:\nAfter downloading the binary, copy it to the /usr/local/bin directory. Add execution permissions:\nSet execution permissions for win32yank.exe using the following command: chmod +x win32yank.exe Uninstall xclip and xsel:\nTo avoid potential conflicts, uninstall xclip and xsel if they are installed on your system as they would be used by default. sudo apt remove xclip sudo apt remove xsel # if it exists These steps ensure the proper installation and configuration of win32yank as the default clipboard tool, avoiding conflicts with xclip and/orxsel.\nNeovim Plugin Installation # 1. Open Neovim: # nvim 2. Allow the plugins to load. # You can issue the command :Lazy to view the progress\nOnce the plugins are installed, exit Neovim.\n3. Compile the ES7 snippets plugin: # cd ~/.local/share/nvim/lazy/vscode-es7-javascript-react-snippets yarn install --frozen-lockfile \u0026amp;\u0026amp; yarn compile This step is crucial for the proper functioning of the snippets plugin.\n4. Language Servers Customizations: # To add more language servers and debug adapters to the ones I\u0026rsquo;ve configured, check out the lsp server, linters, formatters and debug adapter configuration guides.\nYou can use Mason (opened with the command :Mason) to seamlessly install the configured servers. You can also use Mason to ensure certain servers, formatters, linters, and DAPs are installed. Check out the mason-lspconfig, mason-tool-installer and mason-nvim-dap configuration guides for more information on this.\n5. For Java Developers: # Download and setup the java-debug extension. Install it on your neovim data folder ~/.local/share/nvim using the following commands:\ngit clone https://github.com/microsoft/java-debug.git ~/.local/share/nvim/java-debug cd ~/.local/share/nvim/java-debug ./mvnw clean install 6. For Non-WSL users: # Comment the wsl clipboard block on ~/.config/nvim/lua/justice/core/options.lua if you are not using WSL.\nvim.g.clipboard = { name = \u0026#34;win32yank-wsl\u0026#34;, copy = { [\u0026#34;+\u0026#34;] = \u0026#34;win32yank.exe -i --crlf\u0026#34;, [\u0026#34;*\u0026#34;] = \u0026#34;win32yank.exe -i --crlf\u0026#34;, }, paste = { [\u0026#34;+\u0026#34;] = \u0026#34;win32yank.exe -o --lf\u0026#34;, [\u0026#34;*\u0026#34;] = \u0026#34;win32yank.exe -o --lf\u0026#34;, }, cache_enabled = true, } Conclusions # That\u0026rsquo;s it! Your Neovim environment is now configured and ready for use. Customize further based on your preferences, and happy coding!\nNavigate to the next article in this series via the blue drop-down list at the end/beginning of this page for a detailed walkthrough of the keymaps configured in my Neovim setup. Recommendations # Congratulations on setting up your Neovim environment! If you\u0026rsquo;re looking to further enhance your terminal experience, I highly recommend checking out my tmux configuration post linked below. Tmux is a powerful terminal multiplexer that allows you to organize and manage multiple terminal sessions effortlessly.\nMy Tmux Configuration: Elevating Your Terminal Experience 20-01-2024\u0026middot;721 words\u0026middot;4 mins tmux tpm vim-tmux-navigator tmux-themepack tmux-resurrect tmux-continuum neovim Discover how to optimize your workflow, split your terminal into panes, and efficiently navigate through different sessions. Tmux can significantly boost your productivity and provide a seamless terminal experience alongside your Neovim setup.\nHappy coding, and may your terminal sessions be ever productive!\n","date":"16-01-2024","permalink":"/posts/202401-my-neovim-configuration/","section":"Posts","summary":"Introduction # Welcome to my Neovim configuration repository, where I\u0026rsquo;ve curated a powerful setup tailored for developers working with Node.js, React, Python, Golang, and Java.\nScreenshots # Features # Plugins managed with lazy.","title":"My Neovim Configuration Setup Guide"},{"content":"","date":"09-03-2021","permalink":"/tags/cryptography/","section":"Tags","summary":"","title":"cryptography"},{"content":"","date":"09-03-2021","permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF"},{"content":"Introduction # We had an awesome CTF competition which was hosted by CyberSpaceKe that was held at Afralti Conference \u0026amp; Guest House located in Nairobi Kenya. There were a number of challenges to tackle within the 12 hours that the CTF was live, although am going to cover on how I solved the crypto challenge only, on this writeup.\nAdditional Resources # Firstly, we have to know how RSA works since the challenge was based on the RSA concept. A comprehensive description on how RSA works can be found here.\nSolution # For this challenge we are provided with a .zip file\non extracting the crypto.zip, we get three files, a README.txt, setup.py and crypto.py\nMy first step was to read the content of the readme file but it did not explain much. It only explained the padding method used and how to install the dependencies and how to run the script XD My next move was to run the setup.py python3 setup.py install that installs the packages needed for the challenge. let\u0026rsquo;s dive into the actual challenge ;p\nrunning the crypto.py, we are provided with public key, private key and the encrypted flag.. \u0026ldquo;easy one\u0026rdquo; XD we are provided, with the exponent, modulus and the secret(private key) which makes decrypting the flag even more easy\nin RSA; m(message) = ( c ^ d ) % n\nThis can be represented using the pow method in python as m = pow(c, d, n)\nwhere:\nC is the ciphertext in our case the ecrypted flag\nd is the private key;the secret value that was provided from the script\nn is the modulus\nSince we have all the values that are needed, I decided to write a python script to decrypt the flag and convert the values into text\nimport binascii modulus = 34164633714288263 privateKey = 13641456358166273 encryptedFlag = [25093029348589988, 4521027679642871, 24627307819255443, 9960547738404075, 11259248461081440, 22505742667320478, 9377760342138904, 23745739356821857, 25985317747963106, 21569289016296976, 33133895850821816, 6914007185378157, 27796025575756738, 15062199630481745] flag = [] for c in encryptedFlag: message = pow(c, privateKey, modulus) flag.append(message) flag = [hex(i) for i in flag] final = [str(i)[2:] for i in flag] for i in final: try: print(binascii.unhexlify(i).decode(), end=\u0026#34;\u0026#34;) except: pass on running the script, we get the flag;p ","date":"09-03-2021","permalink":"/posts/202103-cyberspaceke-the-cspke-cryptofree-vault-writeup/","section":"Posts","summary":"Introduction # We had an awesome CTF competition which was hosted by CyberSpaceKe that was held at Afralti Conference \u0026amp; Guest House located in Nairobi Kenya. There were a number of challenges to tackle within the 12 hours that the CTF was live, although am going to cover on how I solved the crypto challenge only, on this writeup.","title":"CyberSpaceKE the CSPKE CryptoFREE Vault Writeup"},{"content":"","date":"01-01-0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"01-01-0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]