[{"content":"Introduction # Big O notation is a mathematical tool that helps describe the limiting behavior of a function as its input approaches infinity. It is commonly used in computer science to analyze and compare the efficiency of algorithms. In this article, we will explore the basics of Big O notation and its application in understanding algorithmic performance.\nUnderstanding Big O Notation # Big O notation, denoted as O(f(n)), provides an upper bound on the growth rate of a function concerning the size of its input. In simpler terms, it describes how the runtime or space requirements of an algorithm scale with the size of the input.\nO(1) - Constant Time Complexity # Consider the following Java snippet:\npublic class Main { public void log(int[] numbers) { // O(1) System.out.println(numbers[0]); } } This snippet has a constant time complexity O(1) because the execution time remains constant regardless of the size of the input array. Adding more print statements or operations within the method does not change its constant time nature.\npublic class Main { public void log(int[] numbers) { // O(2) System.out.println(numbers[0]); System.out.println(numbers[0]); } } We have two operations, both running in constant time, so the runtime complexity of the method is still O(1). In this method, the size of the input does not matter; the method will always execute in constant time.\nO(n) - Linear Time Complexity # Linear time complexity, denoted as O(n), describes algorithms whose runtime grows proportionally with the size of the input. Let\u0026rsquo;s explore some examples to better understand this concept.\nBasic Linear Operation # Consider the following Java code:\npublic class Main { public void log(int[] numbers) { // O(n) for (int i = 0; i \u0026lt; numbers.length; i++) System.out.println(numbers[i]); } } In this example, the method iterates through each element in the numbers array, and the time complexity is linear O(n). The larger the input array, the longer the runtime.\nConstant-Time Operations in Linear Context # Now, let\u0026rsquo;s examine a scenario where we add constant-time operations before and after the loop:\npublic class Main { public void log(int[] numbers) { // O(1 + n + 1) -\u0026gt; O(2+n) -\u0026gt; O(n) System.out.println(); // O(1) for (int i = 0; i \u0026lt; numbers.length; i++) // O(n) System.out.println(numbers[i]); System.out.println(); // O(1) } } Despite the added constant-time operations, the overall time complexity remains O(n). This illustrates the principle that constants are typically dropped in Big O analysis.\nMultiple Linear Loops # Let\u0026rsquo;s consider a scenario with two loops:\npublic class Main { public void log(int[] numbers) { // O(n + n) -\u0026gt; O(2n) -\u0026gt; O(n) for (int number : numbers) // O(n) System.out.println(number); for (int number : numbers) // O(n) System.out.println(number); } } The presence of two linear operations still results in linear time complexity O(n), as constants are dropped in Big O notation.\nLinear Time Complexity with Multiple Parameters # Adding more parameters to a method does not change its fundamental linear time complexity:\npublic class Main { public void log(int[] numbers, String[] names) { // O(n + m) -\u0026gt; O(n) for (int number : numbers) // O(n) System.out.println(number); for (String name : names) // O(m) System.out.println(name); } } In this case, the overall runtime complexity is O(n), as we focus on the parameter that has linear growth.\nO(n2) - Quadratic Time Complexity # Quadratic time complexity, denoted as O(n²), characterizes algorithms that exhibit a growth rate proportional to the square of the input size. This often occurs with nested loops, where each iteration contributes to the overall growth. Let\u0026rsquo;s delve into examples to gain a clearer understanding.\nNested Loop Scenario # Consider the following Java code:\npublic class Main { public void log(int[] numbers) { // O(n * n) -\u0026gt; O(n^2) for (int first : numbers) // O(n) for (int second : numbers) // O(n) System.out.println(first + \u0026#34;, \u0026#34; + second); } } In this example, the outer loop iterates through each element in the numbers array, and for each iteration of the outer loop, the inner loop also traverses the entire array. The result is a quadratic time complexity of O(n²).\nAlgorithms that run in O(n²) run slower than algorithms that run in O(n)\nAdditional Operations in Quadratic Context # Let\u0026rsquo;s examine a scenario where we have additional operations before or after the nested loop:\npublic class Main { public void log(int[] numbers) { // O(n + n^2) -\u0026gt; O(n^2) for (int number : numbers) // O(n) System.out.println(number); for (int first : numbers) // O(n) for (int second : numbers) // O(n) System.out.println(first + \u0026#34;, \u0026#34; + second); } } In this example, the first loop has a time complexity of O(n) as it iterates through each element in the numbers array. The nested loop, however, has a quadratic time complexity of O(n²), as it iterates through each combination of elements in the array. When we express the overall time complexity as O(n + n²), we recognize that the dominant factor is the quadratic term n².\nThe rationale for dropping the linear term n is rooted in the principle of Big O notation, where we focus on the dominant term that contributes the most to the growth rate. In this context, as the size of the input n becomes larger, the impact of the quadratic term n² becomes significantly more substantial, overshadowing the linear term. Therefore, for the purpose of understanding how the cost of the algorithm increases relative to its input size, we simplify the expression to O(n²).\nImpact of Nested Loops on Growth Rate # What if we had nested loops within the original nested loop:\npublic class Main { public void log(int[] numbers) { // O(n * n * n) -\u0026gt; O(n^3) for (int first : numbers) // O(n) for (int second : numbers) // O(n) for (int third : numbers) // O(n) System.out.println(first + \u0026#34;, \u0026#34; + second + \u0026#34;, \u0026#34; + third); } } In this case, the time complexity becomes cubic O(n³), showcasing how the growth rate accelerates with additional nested loops.\nAlgorithms that run in O(n³) are far slower than those that run in O(n²) and O(n). The exponential increase in computational cost makes algorithms with cubic time complexity less scalable and less efficient compared to their quadratic and linear counterparts. This underscores the importance of considering the time complexity when designing algorithms for optimal performance.\nO(log n) - Logarithmic Time Complexity # Another growth rate we are going to talk about is the logarithmic growth, denoted as O(log n). Here is a logarithmic curve for better visualization:\nCompare it with a linear curve:\nThe linear curve grows at the same rate, while the logarithmic curve slows down at some point. An algorithm that runs in logarithmic time is more efficient and more scalable than an algorithm that runs in linear or quadratic time.\nExample # Let\u0026rsquo;s consider an algorithm with logarithmic time complexity:\nAssuming we have an array of sorted numbers from 1 to 10 and we want to find the number 10. We can implement the Binary Search algorithm, which runs in logarithmic time.\npublic class Main { public int binarySearch(int[] sortedArray, int target) { int low = 0; int high = sortedArray.length - 1; while (low \u0026lt;= high) { int mid = (low + high) / 2; if (sortedArray[mid] == target) { return mid; // Target found } else if (sortedArray[mid] \u0026lt; target) { low = mid + 1; // Search in the right half } else { high = mid - 1; // Search in the left half } } return -1; // Target not found } } In this example, the Binary Search algorithm efficiently narrows down the search space in each iteration. The key advantage comes from the fact that it operates on a sorted array. By continually halving the search space, it minimizes the number of comparisons needed to find the target element. In contrast, a linear search would require iterating through all items in the array, and in the worst case scenario, the target item could be the last element. This linear approach becomes increasingly inefficient as the size of the dataset grows.\nThe logarithmic time complexity O(log n) of the Binary Search algorithm makes it significantly more efficient, especially when dealing with large datasets, as it avoids unnecessary iterations and quickly converges to the target element.\nO(2n) - Exponential Time Complexity # Another type of growth is exponential growth, denoted as O(2ⁿ).\nThe exponential growth is the opposite of logarithmic growth, where the curve grows faster and faster.\nThe logarithmic curve slows down as the input size grows, but the exponential curve grows faster and faster. An algorithm that runs in exponential time is not scalable and would become very slow very soon.\nExample # Let\u0026rsquo;s explore an algorithm with exponential time complexity:\npublic class Main { public int fibonacci(int n) { if (n \u0026lt;= 1) { return n; } else { return fibonacci(n - 1) + fibonacci(n - 2); } } } In this example, the Fibonacci algorithm, which calculates Fibonacci numbers recursively, exhibits exponential time complexity O(2ⁿ). As the input value increases, the number of recursive calls grows exponentially, leading to a rapid increase in computational cost.\nExponential time complexity is not scalable for large inputs, making algorithms with this complexity impractical for certain applications.\nSpace Complexity # We\u0026rsquo;ve seen how Big O Notation helps describe the runtime complexity of algorithms. Ideally, we want our algorithms to be fast, scalable, and use minimal memory. However, this ideal is rarely achieved. Most often, we must make trade-offs between saving time and saving space.\nSometimes we have extra space, allowing us to optimize algorithms for speed and scalability. Other times, especially when building apps for small devices, space is limited, and we prioritize optimizing for space over scalability.\nSo, we need a way to talk about how much space an algorithm requires, and that\u0026rsquo;s where we use the Big O Notation again.\nO(x) # public class Main { public void greet(String[] names) { // O(1) space for (int i = 0; i \u0026lt; names.length; i++) System.out.println(\u0026#34;Hi\u0026#34; + names[i]); } } In this greet method, the loop variable i is independent of the size of the input. Whether the array has 10 or a million items, the method will only allocate a constant amount of memory for the loop variable, representing O(1) space complexity.\nWhat if we declare a copy string array and initialize it as shown below:\npublic class Main { public void greet(String[] names) { // O(n) space String[] copy = new String[names.length]; for (int i = 0; i \u0026lt; names.length; i++) copy[i] = names[i]; } } Conclusion # The growth rates we\u0026rsquo;ve explored are common in algorithmic analysis. While they represent just a subset of possibilities, they capture scenarios frequently encountered.\nIn this series, we\u0026rsquo;ll mainly focus on runtime complexity, tackling its intricate aspects. Nevertheless, it\u0026rsquo;s crucial to also consider space complexity in your algorithms, especially in situations where memory is limited. As you navigate algorithmic challenges, think creatively about preserving memory.\nReferences # Ultimate Data Structures \u0026amp; Algorithms: Part 1 by Mosh Hamedani Wikipedia - Big O Notation ","date":"10-02-2024","permalink":"/posts/202402-big-o-notation/","section":"Posts","summary":"Introduction # Big O notation is a mathematical tool that helps describe the limiting behavior of a function as its input approaches infinity. It is commonly used in computer science to analyze and compare the efficiency of algorithms.","title":"Big O Notation: Understanding Algorithmic Efficiency"},{"content":"","date":"10-02-2024","permalink":"/tags/big-o-notation/","section":"Tags","summary":"","title":"big-o-notation"},{"content":"","date":"10-02-2024","permalink":"/series/data-structures-and-algorithms/","section":"Series","summary":"","title":"Data Structures and Algorithms"},{"content":"","date":"10-02-2024","permalink":"/tags/data-structures-and-algorithms/","section":"Tags","summary":"","title":"data-structures-and-algorithms"},{"content":"","date":"10-02-2024","permalink":"/","section":"Justice Nyaga","summary":"","title":"Justice Nyaga"},{"content":"","date":"10-02-2024","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"10-02-2024","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"10-02-2024","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"Introduction # Developing Java code in Neovim can be a seamless experience with the right Language Server Protocol (LSP) setup. In this blog post, we will explore how to enhance your Neovim environment for Java development by configuring nvim-jdtls. This plugin, available at nvim-jdtls, offers a comprehensive set of features tailored for Java, addressing challenges such as navigating to the definition of methods and classes outside your project.\nBefore we proceed, ensure you\u0026rsquo;ve checked out my Neovim configuration post, which complements this setup:\nMy Neovim Configuration Setup Guide 16-01-2024\u0026middot;500 words\u0026middot;3 mins lua neovim Prerequisites # Neovim version \u0026gt;= 0.6.0\nVerify your Neovim version using:\nnvim --version Java runtime environment 17 and above\nInstall the desired Java version, ensuring it is 17 or above. For example, to install OpenJDK version 21:\nsudo apt install openjdk-21-jdk Set the JAVA_HOME environment variable to point to the JDK or JRE directory. Identify the correct path using:\nsudo update-alternatives --config java Set JAVA_HOME in your .bashrc or .zshrc:\nexport JAVA_HOME=/path/to/openjdk-21 For example:\nexport JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64 eclipse.jdt.ls\nDownload and extract a snapshot build from http://download.eclipse.org/jdtls/snapshots/:\nwget https://download.eclipse.org/jdtls/snapshots/jdt-language-server-1.31.0-202312211634.tar.gz \u0026amp;\u0026amp; sudo tar -C /usr/local -xzf jdt-language-server-1.31.0-202312211634.tar.gz Installing nvim-jdtls plugin # Install the plugin using your preferred plugin manager. If using Lazy, add the following line to your init.lua file and install with :Lazy:\n\u0026#34;mfussenegger/nvim-jdtls\u0026#34;, -- java lsp Install jdtls using mason by initiating mason with :Mason and proceeding with the installation.\nConfiguration # To avoid conficts, ensure you do not run nvim-lspconfig and nvim-jdtls simultaneously. Add the following setup_handler configuration to your nvim-lspconfig in my case it\u0026rsquo;s ~/.config/nvim/lua/justice/plugins/lsp/lspconfig.lua.\n-- empty function to ignore jdtls local noop = function() end require(\u0026#34;mason-lspconfig\u0026#34;).setup_handlers({ function(server_name) lspconfig[server_name].setup({ on_attach = on_attach, capabilities = capabilities, }) end, [\u0026#34;jdtls\u0026#34;] = noop, }) Create a ~/.config/nvim/ftplugin/java.lua file with the following code for jdtls configuration:\nlocal jdtls_bin = vim.fn.stdpath(\u0026#34;data\u0026#34;) .. \u0026#34;/mason/bin/jdtls\u0026#34; local keymap = vim.keymap local opts = { noremap = true, silent = true } local lsp_attach = function(client, bufnr) opts.buffer = bufnr -- set keybinds. Copied my lspconfig keybinds here end local config = { cmd = { jdtls_bin }, root_dir = vim.fs.dirname(vim.fs.find({ \u0026#34;gradlew\u0026#34;, \u0026#34;.git\u0026#34;, \u0026#34;mvnw\u0026#34; }, { upward = true })[1]), on_attach = lsp_attach, } require(\u0026#34;jdtls\u0026#34;).start_or_attach(config) Explore my configuration files by visiting lspconfig.lua and java.lua.\nConclusion # Kudos on completing the setup! Your Neovim environment is now finely tuned for Java development with the configured Java LSP. Wishing you smooth coding sessions ahead - Happy coding!\n","date":"05-02-2024","permalink":"/posts/202402-configuring-java-lsp-for-neovim-with-nvim-jdtls/","section":"Posts","summary":"Introduction # Developing Java code in Neovim can be a seamless experience with the right Language Server Protocol (LSP) setup. In this blog post, we will explore how to enhance your Neovim environment for Java development by configuring nvim-jdtls.","title":"Configuring Java LSP for Neovim with nvim-jdtls"},{"content":"","date":"05-02-2024","permalink":"/tags/neovim/","section":"Tags","summary":"","title":"neovim"},{"content":"","date":"05-02-2024","permalink":"/tags/nvim-jdtls/","section":"Tags","summary":"","title":"nvim-jdtls"},{"content":"","date":"05-02-2024","permalink":"/tags/nvim-lspconfig/","section":"Tags","summary":"","title":"nvim-lspconfig"},{"content":"I\u0026rsquo;m a fullstack software developer based in Kenya. I\u0026rsquo;m proficient in Python, Django, Javascript, Node.js, React, React Native and Golang.\nDive into my blog for concise insights and hands-on experiences, where we\u0026rsquo;ll unravel the intricacies of software engineering together. Let\u0026rsquo;s embark on this coding journey!\nFeel free to reach out.\n","date":"01-02-2024","permalink":"/about/","section":"Justice Nyaga","summary":"I\u0026rsquo;m a fullstack software developer based in Kenya. I\u0026rsquo;m proficient in Python, Django, Javascript, Node.js, React, React Native and Golang.\nDive into my blog for concise insights and hands-on experiences, where we\u0026rsquo;ll unravel the intricacies of software engineering together.","title":"About Me"},{"content":"Step into the realm of my digital playground, a space where curiosity meets code and innovation takes flight. Within these project walls, each endeavor is a crafted narrative, a testament to my commitment to perpetual learning and creative exploration.\nLogo Title Description Link Proshop A fake shopping app built on React. The app utilizes proshop_api (Django REST API) sitegithub Proshop-Api An e-commerce REST API crafted with Django and Django Rest Framework, incorporating diverse shopping app features. sitegithub DoneWithIt A faux native app marketplace designed for selling items you no longer need. github ","date":"31-01-2024","permalink":"/projects/","section":"Justice Nyaga","summary":"Step into the realm of my digital playground, a space where curiosity meets code and innovation takes flight. Within these project walls, each endeavor is a crafted narrative, a testament to my commitment to perpetual learning and creative exploration.","title":"Projects"},{"content":"Introduction # Welcome to this comprehensive guide on installing and configuring Ubuntu Desktop environment on Windows Subsystem for Linux 2 (WSL2). Enhance your development environment and streamline your coding experience with this step-by-step walkthrough.\nThis post assumes that you have already installed Ubuntu within WSL2. If not, please do install it before proceeding.\nStep 1: Install Ubuntu Desktop and Mesa-utils # Begin by installing the Ubuntu Desktop and mesa-utils packages:\nsudo apt update sudo apt install ubuntu-desktop mesa-utils Troubleshooting for \u0026ldquo;Transport endpoint is not connected\u0026rdquo; error # If you encounter the error \u0026ldquo;Transport endpoint is not connected\u0026rdquo; during the setup, perform the following troubleshooting steps:\nPress Ctrl + C to skip packages with the error. Run the following commands: sudo mv /etc/acpi/events /etc/acpi/events.bak sudo ln -s /dev/null /etc/systemd/system/acpid.service sudo ln -s /dev/null /etc/systemd/system/acpid.path Run the following command to reconfigure the unpacked packages that were skipped on the previous step.\nsudo dpkg --configure -a Step 2: Set Up Environment Variables # Configure environment variables for persistent settings. It\u0026rsquo;s recommended to add these to your .bashrc or .zshrc:\nexport DISPLAY=\u0026#34;$(grep nameserver /etc/resolv.conf | sed \u0026#39;s/nameserver //\u0026#39;):0\u0026#34; export LIBGL_ALWAYS_INDIRECT=0 Step 3: Install VcXsrv on Windows # On the Windows side, install VcXsrv. After installation, choose the following setup options:\nMultiple windows\nDisplay number: 0\nStart no client\nCheck everything on Extra settings, that is, clipboard, primary selection, Native opengl, Disable access control\nYou can save the configuration for future use\nClick finish to start the server\nStep 4: Verify Installation with xeyes # Ensure VcXsrv is running and test the setup by opening xeyes app or any other installed desktop app such as firefox on your WSL terminal:\nxeyes Conclusion # The successful opening of the xeyes app indicates that you have seamlessly set up the Ubuntu Desktop environment on WSL2. Happy coding!\n","date":"31-01-2024","permalink":"/posts/202401-setting-up-ubuntu-desktop-environment-on-wsl2/","section":"Posts","summary":"A comprehensive guide to installing and configuring the Ubuntu Desktop environment on Windows Subsystem for Linux 2 (WSL2). Enhance your development environment and streamline your coding experience with this step-by-step walkthrough.","title":"Setting up Ubuntu Desktop Environment on WSL2"},{"content":"","date":"31-01-2024","permalink":"/tags/ubuntu/","section":"Tags","summary":"","title":"ubuntu"},{"content":"","date":"31-01-2024","permalink":"/tags/ubuntu-desktop/","section":"Tags","summary":"","title":"ubuntu-desktop"},{"content":"","date":"31-01-2024","permalink":"/tags/vcxsrv/","section":"Tags","summary":"","title":"vcxsrv"},{"content":"","date":"31-01-2024","permalink":"/tags/wsl2/","section":"Tags","summary":"","title":"wsl2"},{"content":"Introduction # Welcome to the world of Tmux, where terminal multitasking becomes a breeze. In this guide, we\u0026rsquo;ll walk through setting up and enhancing your Tmux experience with a customized configuration.\nDesigned for efficient integration with Neovim, this carefully crafted configuration aims to streamline your terminal workflow. It provides a seamless and productive environment for both Tmux and Neovim enthusiasts. Whether you\u0026rsquo;re a seasoned user or just diving into the world of terminal customization, this guide will help you unlock the full potential of Tmux in conjunction with Neovim. Let\u0026rsquo;s dive in!\nConfiguration Setup Step # Follow these steps to set up and enhance your Tmux experience:\nInstall Tmux:\nIf Tmux is not already installed on your system, you can install it using your package manager. For example, on Debian-based systems, run:\nsudo apt-get install tmux Verify the installation by checking the Tmux version:\ntmux -V Retrieve the Configuration File:\nDownload the Tmux configuration file and seamlessly integrate it into your home directory using the following command:\nwget https://raw.githubusercontent.com/justicenyaga/my_nvim_config/main/.tmux.conf -O ~/.tmux.conf Install Tmux Plugin Manager (tpm):\nClone the Tmux Plugin Manager repository to your local machine:\ngit clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm Create a Tmux session:\nStart a new Tmux session with a specific name (replace SessionName with your desired name):\ntmux new -s SessionName This should create a session and attach you to the created session.\nReload the Tmux configuration file:\nPress your Tmux prefix key (the configuration file uses Ctrl + N) followed by r to reload the configuration file:\n\u0026lt;C-n\u0026gt;r On the configuration file, replace C-n with a prefered key bind to override the default prefix key bind, on the following lines:\nset -g prefix C-n bind-key C-n send-prefix Install Tmux plugins:\nWhile inside a Tmux session, install plugins by pressing your Tmux prefix key followed by I (uppercase):\n\u0026lt;C-n\u0026gt;I Again, replace \u0026lt;C-n\u0026gt; with your configured prefix key bind. That\u0026rsquo;s it! Your Tmux environment is now configured with the specified settings and plugins. Customize further based on your preferences.\nUsage # Keybinds Explanation # Prefix Key: C-n\nThe prefix key is set to C-n for easier accessibility and to avoid conflicts with the default C-b. It\u0026rsquo;s a comfortable and ergonomic choice. Vertical Split: prefix + |\nThe keybind for vertical split is set to prefix + | for better visualization. The vertical bar (|) visually represents a vertical split, making it intuitive and memorable. Horizontal Split: prefix + -\nHorizontal split is initiated with prefix + -, providing a straightforward and balanced key combination for creating horizontal panes. Reload Configuration: prefix + r\nReloading the configuration is done with prefix + r, making it quick and easy to apply any changes made to the configuration file. Resize Panes: prefix + j/k/l/h\nResizing panes is streamlined with prefix + j/k/l/h for downward, upward, right, and left respectively. The mnemonic association with arrow keys makes it intuitive. Maximize Pane: prefix + m\nThe keybind prefix + m maximizes the active pane, providing a convenient way to focus on one task at a time. Enable Mouse Mode: prefix + M\nMouse mode is toggled with prefix + M, allowing for easy resizing and scrolling using the mouse. Copy Mode and Selection # Enter Copy Mode: prefix + [\nCopy mode is entered with prefix + [, initiating vi-style selection for efficient copying of text. Start Selection: v\nText selection starts with the v key in copy mode, following the vi-style conventions. Copy Selection: y\nThe selected text is copied using the y key in copy mode, mirroring vi-style copy operations. No Exit on Mouse Drag:\nDragging with the mouse in copy mode (MouseDragEnd1Pane) won\u0026rsquo;t exit copy mode, providing a seamless experience. Neovim Integration # No Delay for Exiting Insert Mode:\nThe delay for exiting insert mode with ESC in Neovim is removed (escape-time 10), ensuring a smooth transition. Tmux Plugins # Tmux Plugin Manager (tpm):\nThe Tmux Plugin Manager is initialized at the bottom of the configuration, allowing easy management of plugins. List of Plugins:\nvim-tmux-navigator: Navigate seamlessly between Vim and Tmux panes. tmux-themepack: A collection of themes for Tmux. tmux-resurrect: Persist Tmux sessions after computer restart. tmux-continuum: Automatically save sessions every 15 minutes. Theme: Powerline Cyan\nThe chosen theme from tmux-themepack is powerline/default/cyan for a visually appealing and distinctive look. Remember to customize these keybinds further based on your preferences and workflow!\n","date":"20-01-2024","permalink":"/posts/202401-my-tmux-configuration/","section":"Posts","summary":"Introduction # Welcome to the world of Tmux, where terminal multitasking becomes a breeze. In this guide, we\u0026rsquo;ll walk through setting up and enhancing your Tmux experience with a customized configuration.","title":"My Tmux Configuration: Elevating Your Terminal Experience"},{"content":"","date":"20-01-2024","permalink":"/tags/tmux/","section":"Tags","summary":"","title":"tmux"},{"content":"","date":"20-01-2024","permalink":"/tags/tmux-continuum/","section":"Tags","summary":"","title":"tmux-continuum"},{"content":"","date":"20-01-2024","permalink":"/tags/tmux-resurrect/","section":"Tags","summary":"","title":"tmux-resurrect"},{"content":"","date":"20-01-2024","permalink":"/tags/tmux-themepack/","section":"Tags","summary":"","title":"tmux-themepack"},{"content":"","date":"20-01-2024","permalink":"/tags/tpm/","section":"Tags","summary":"","title":"tpm"},{"content":"","date":"20-01-2024","permalink":"/tags/vim-tmux-navigator/","section":"Tags","summary":"","title":"vim-tmux-navigator"},{"content":"","date":"16-01-2024","permalink":"/tags/lua/","section":"Tags","summary":"","title":"lua"},{"content":"Introduction # Welcome to my Neovim configuration! Follow these steps to set up and enhance your Neovim experience. Prerequisites # Before diving into the configuration, ensure you have the following prerequisites installed:\nEnsure you have Neovim v0.9 and Above: Ensure that you have Neovim version 0.9 or above installed. Check your Neovim version using:\nnvim --version Install python3.10-venv: Install the python3.10-venv package using the following command:\nsudo apt install python3.10-venv Node Packages: Install neovim and tree-sitter node packages by running the following command:\nnpm i -g neovim tree-sitter pynvim Package: Install the pynvim package using pip:\npython3 -m pip install -U pynvim Ensure that the python command points to python3 by adding the following alias on your .bashrc or .zshrc:\nalias python=python3 ripgrep Package:\nFor telescope\u0026rsquo;s live_grep to work, you need the ripgrep package. Install it using:\nsudo apt install ripgrep Clone Configuration Repository: Clone my Neovim configuration repository to ~/.config/nvim:\ngit clone https://github.com/justicenyaga/my_nvim_config.git ~/.config/nvim For WSL users, Download win32yank to interact with windows clipboard:\nDownload win32yank binary here https://github.com/equalsraf/win32yank/releases then copy it to /usr/local/bin\nAdd execution permissions\nchmod +x win32yank.exe Uninstall xclip if you have it installed to avoid potential conflit as it would be used as the default:\nsudo apt remove xclip Neovim Plugin Installation # Open Neovim:\nnvim Allow the plugins to load.\nYou can issue the command :Lazy to view the progress\nOnce the plugins are installed, exit Neovim.\nCompile the ES7/Javascript/React snippets plugin:\ncd ~/.local/share/nvim/lazy/vscode-es7-javascript-react-snippets yarn install --frozen-lockfile \u0026amp;\u0026amp; yarn compile This step is crucial for the proper functioning of the snippets plugin.\nCustomize Your Language Server Protocol (LPS), Linters, and Formatters Installation:\nOpen up Mason using the command :Mason to seamlessly install and configure your preferred Language Server Protocol, along with Linters and Formatters. Tailor these tools to your specific needs, providing a customized and optimized setup for an enhanced coding experience.\nFor WSL users: To interact with system clipboard, uncomment the wsl clipboard block on ~/.config/nvim/lua/justice/core/options.lua\n-- vim.g.clipboard = { -- name = \u0026#34;win32yank-wsl\u0026#34;, -- copy = { -- [\u0026#34;+\u0026#34;] = \u0026#34;win32yank.exe -i --crlf\u0026#34;, -- [\u0026#34;*\u0026#34;] = \u0026#34;win32yank.exe -i --crlf\u0026#34;, -- }, -- paste = { -- [\u0026#34;+\u0026#34;] = \u0026#34;win32yank.exe -o --lf\u0026#34;, -- [\u0026#34;*\u0026#34;] = \u0026#34;win32yank.exe -o --lf\u0026#34;, -- }, -- cache_enabled = true, -- } That\u0026rsquo;s it! Your Neovim environment is now configured and ready for use. Customize further based on your preferences, and happy coding!\nRecommendations # Congratulations on setting up your Neovim environment! If you\u0026rsquo;re looking to further enhance your terminal experience, I highly recommend checking out my tmux configuration post linked below. Tmux is a powerful terminal multiplexer that allows you to organize and manage multiple terminal sessions effortlessly.\nMy Tmux Configuration: Elevating Your Terminal Experience 20-01-2024\u0026middot;721 words\u0026middot;4 mins tmux tpm vim-tmux-navigator tmux-themepack tmux-resurrect tmux-continuum neovim Discover how to optimize your workflow, split your terminal into panes, and efficiently navigate through different sessions. Tmux can significantly boost your productivity and provide a seamless terminal experience alongside your Neovim setup.\nHappy coding, and may your terminal sessions be ever productive!\n","date":"16-01-2024","permalink":"/posts/202401-my-neovim-configuration/","section":"Posts","summary":"Introduction # Welcome to my Neovim configuration! Follow these steps to set up and enhance your Neovim experience. Prerequisites # Before diving into the configuration, ensure you have the following prerequisites installed:","title":"My Neovim Configuration Setup Guide"},{"content":"","date":"09-03-2021","permalink":"/tags/cryptography/","section":"Tags","summary":"","title":"cryptography"},{"content":"","date":"09-03-2021","permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF"},{"content":"Introduction # We had an awesome CTF competition which was hosted by CyberSpaceKe that was held at Afralti Conference \u0026amp; Guest House located in Nairobi Kenya. There were a number of challenges to tackle within the 12 hours that the CTF was live, although am going to cover on how I solved the crypto challenge only, on this writeup.\nAdditional Resources # Firstly, we have to know how RSA works since the challenge was based on the RSA concept. A comprehensive description on how RSA works can be found here.\nSolution # For this challenge we are provided with a .zip file\non extracting the crypto.zip, we get three files, a README.txt, setup.py and crypto.py\nMy first step was to read the content of the readme file but it did not explain much. It only explained the padding method used and how to install the dependencies and how to run the script XD My next move was to run the setup.py python3 setup.py install that installs the packages needed for the challenge. let\u0026rsquo;s dive into the actual challenge ;p\nrunning the crypto.py, we are provided with public key, private key and the encrypted flag.. \u0026ldquo;easy one\u0026rdquo; XD we are provided, with the exponent, modulus and the secret(private key) which makes decrypting the flag even more easy\nin RSA; m(message) = ( c ^ d ) % n\nThis can be represented using the pow method in python as m = pow(c, d, n)\nwhere:\nC is the ciphertext in our case the ecrypted flag\nd is the private key;the secret value that was provided from the script\nn is the modulus\nSince we have all the values that are needed, I decided to write a python script to decrypt the flag and convert the values into text\nimport binascii modulus = 34164633714288263 privateKey = 13641456358166273 encryptedFlag = [25093029348589988, 4521027679642871, 24627307819255443, 9960547738404075, 11259248461081440, 22505742667320478, 9377760342138904, 23745739356821857, 25985317747963106, 21569289016296976, 33133895850821816, 6914007185378157, 27796025575756738, 15062199630481745] flag = [] for c in encryptedFlag: message = pow(c, privateKey, modulus) flag.append(message) flag = [hex(i) for i in flag] final = [str(i)[2:] for i in flag] for i in final: try: print(binascii.unhexlify(i).decode(), end=\u0026#34;\u0026#34;) except: pass on running the script, we get the flag;p ","date":"09-03-2021","permalink":"/posts/202103-cyberspaceke-the-cspke-cryptofree-vault-writeup/","section":"Posts","summary":"Introduction # We had an awesome CTF competition which was hosted by CyberSpaceKe that was held at Afralti Conference \u0026amp; Guest House located in Nairobi Kenya. There were a number of challenges to tackle within the 12 hours that the CTF was live, although am going to cover on how I solved the crypto challenge only, on this writeup.","title":"CyberSpaceKE the CSPKE CryptoFREE Vault Writeup"},{"content":"","date":"01-01-0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"01-01-0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]